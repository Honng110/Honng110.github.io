<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>带电粒子在电磁场中运动模拟平台</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #121212;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            padding: 15px 20px;
            background-color: #1e1e1e;
            border-bottom: 1px solid #333;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .header h1 {
            font-size: 1.8rem;
            margin-bottom: 5px;
            color: #4a9eff;
            font-weight: 600;
        }
        
        .header p {
            font-size: 0.9rem;
            color: #999;
        }
        
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .left-panel {
            width: 125px; /* 减小左侧面板宽度为原来的一半 */
            background-color: #1e1e1e;
            padding: 15px;
            overflow-y: auto;
            border-right: 1px solid #333;
            transition: width 0.3s ease, padding 0.3s ease;
            position: relative;
            min-width: 50px;
        }

        .left-panel.collapsed {
            width: 50px;
            padding: 15px 5px;
        }

        .left-panel.collapsed .panel-title,
        .left-panel.collapsed .element-card p,
        .left-panel.collapsed .element-card h3 {
            display: none;
        }

        .left-panel.collapsed .element-card {
            padding: 10px;
            text-align: center;
        }

        .left-panel.collapsed .element-card i {
            font-size: 1.5rem;
            margin: 0;
        }
        
        .panel-title {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #4a9eff;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
            font-weight: 600;
        }
        
        .element-card {
            background-color: #252525;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid #333;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .element-card:hover {
            background-color: #2a2a2a;
            border-color: #4a9eff;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .element-card.active {
            background-color: #2a3a5a;
            border-color: #4a9eff;
        }
        
        .element-card h3 {
            font-size: 1rem;
            margin-bottom: 8px;
            color: #4a9eff;
            font-weight: 600;
        }
        
        .element-card p {
            font-size: 0.85rem;
            color: #999;
        }
        
        .center-panel {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: #121212;
            display: flex;
            flex-direction: column;
        }
        
        #canvas-container {
            flex: 1;
            overflow: auto;
            position: relative;
            background-color: #121212;
            touch-action: none; /* 禁用浏览器默认触摸行为 */
        }
        
        #simulation-canvas {
            background-color: #121212;
            display: block;
            transform-origin: 0 0;
        }
        
        .canvas-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(30, 30, 30, 0.9);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.85rem;
            color: #e0e0e0;
            z-index: 10;
            border: 1px solid #333;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .right-panel {
            width: 240px; /* 增加右侧面板宽度为现在的1.5倍 */
            background-color: #1e1e1e;
            padding: 15px;
            overflow-y: auto;
            border-left: 1px solid #333;
            transition: width 0.3s ease, padding 0.3s ease;
            position: relative;
            min-width: 50px;
        }

        .right-panel.collapsed {
            width: 50px;
            padding: 15px 5px;
        }

        .right-panel.collapsed * {
            display: none;
        }

        .right-panel.collapsed #no-selection-panel {
            display: block;
            text-align: center;
            padding: 10px 0;
        }

        .right-panel.collapsed #no-selection-panel i {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .right-panel.collapsed #no-selection-panel p {
            display: none;
        }
        
        /* 响应式设计：针对iPad等平板设备 */
        @media (max-width: 1200px) {
            .left-panel {
                width: 125px; /* 保持减小后的宽度 */
            }
            
            .right-panel {
                width: 240px; /* 增加右侧面板宽度为现在的1.5倍 */
            }
        }
        
        @media (max-width: 992px) {
            .container {
                flex-direction: column;
            }
            
            .left-panel {
                width: 100%;
                height: auto;
                max-height: 200px;
                border-right: none;
                border-bottom: 1px solid #333;
                display: flex;
                flex-wrap: wrap;
                overflow-y: auto;
            }
            
            .element-card {
                width: calc(50% - 10px);
                margin-right: 10px;
                margin-bottom: 10px;
            }
            
            .panel-title {
                width: 100%;
            }
            
            .right-panel {
                width: 100%;
                height: auto;
                max-height: 250px;
                border-left: none;
                border-top: 1px solid #333;
            }
            
            .center-panel {
                flex: 1;
                min-height: 400px;
            }
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.4rem;
            }
            
            .control-button {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            
            .element-card {
                width: 100%;
                margin-right: 0;
            }
        }
        
        .property-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        
        .property-group h3 {
            font-size: 1.1rem;
            margin-bottom: 12px;
            color: #4a9eff;
            font-weight: 600;
        }
        
        .property-item {
            margin-bottom: 12px;
        }
        
        .property-item label {
            display: block;
            font-size: 0.9rem;
            margin-bottom: 5px;
            color: #ccc;
            font-weight: 500;
        }
        
        .property-item input, 
            .property-item select {
                width: 100%;
                padding: 12px 15px;
                background-color: #252525;
                border: 1px solid #444;
                border-radius: 6px;
                color: #e0e0e0;
                font-size: 1rem;
                transition: border-color 0.3s;
                min-height: 48px;
            }
        
        .property-item input:focus, 
        .property-item select:focus {
            outline: none;
            border-color: #4a9eff;
        }
        
        .input-with-unit {
            display: flex;
            align-items: center;
        }
        
        .input-with-unit input {
            flex: 1;
            margin-right: 5px;
        }
        
        .unit {
            min-width: 40px;
            color: #999;
            font-size: 0.85rem;
        }
        
        .control-panel {
            padding: 15px 20px;
            background-color: #1e1e1e;
            border-top: 1px solid #333;
            display: flex;
            justify-content: center;
            gap: 15px;
            box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .control-button {
            padding: 12px 24px;
            background-color: #252525;
            color: #e0e0e0;
            border: 1px solid #333;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
            min-height: 56px;
            touch-action: manipulation;
        }
        
        .control-button:hover {
            background-color: #2a2a2a;
            border-color: #4a9eff;
            transform: translateY(-2px);
        }
        
        .control-button.primary {
            background-color: #1971c2;
            color: white;
        }
        
        .control-button.primary:hover {
            background-color: #1864ab;
        }
        
        .control-button.warning {
            background-color: #e67700;
            color: white;
        }
        
        .control-button.warning:hover {
            background-color: #d35400;
        }
        
        .no-selection {
            text-align: center;
            padding: 40px 20px;
            color: #777;
        }
        
        .physics-info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        
        .physics-info-label {
            color: #555;
        }
        
        .physics-info-value {
            color: #1971c2;
            font-weight: 500;
        }
        
        .selection-box {
            position: absolute;
            border: 2px solid #4a9eff;
            background-color: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 5;
        }
        
        .transform-controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background-color: rgba(30, 30, 30, 0.9);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #333;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 10;
            display: none;
        }
        
        .transform-controls.active {
            display: flex;
        }
        
        .transform-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #252525;
            border: 1px solid #444;
            color: #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s;
        }
        
        .transform-btn:hover {
            background-color: #2a2a2a;
            border-color: #4a9eff;
        }
        
        .gesture-hint {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(30, 30, 30, 0.9);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.8rem;
            color: #999;
            border: 1px solid #333;
            display: none;
        }
        
        .gesture-hint.active {
            display: block;
        }
        
        /* 悬浮按钮样式 */
        .floating-buttons {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        
        .floating-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: rgba(30, 30, 30, 0.9);
            border: 1px solid #4a9eff;
            color: #4a9eff;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .floating-btn:hover {
            background-color: rgba(74, 158, 255, 0.2);
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        
        .floating-btn:active {
            transform: scale(0.95);
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="header">
        <h1>带电粒子在电磁场中运动模拟平台</h1>
        <p>点击左侧元素添加到画布，点击画布上的元素可编辑属性，支持移动、旋转、缩放操作</p>
    </div>
    
    <div class="container">
        <!-- 中间画布区域 -->
        <div class="center-panel">
            <!-- 悬浮按钮 -->
            <div class="floating-buttons">
                <button class="floating-btn" id="add-emitter-btn" title="添加粒子发射器">
                    <i class="fas fa-bullseye"></i>
                </button>
                <button class="floating-btn" id="add-field-btn" title="添加磁场">
                    <i class="fas fa-magnet"></i>
                </button>
                <button class="floating-btn" id="add-electric-field-btn" title="添加电场">
                    <i class="fas fa-bolt"></i>
                </button>
            </div>
            <div id="canvas-container">
                <canvas id="simulation-canvas"></canvas>
                <div class="canvas-overlay">
                    画布比例: <span id="canvas-scale">100%</span> | 
                    粒子数量: <span id="particle-count">0</span>
                </div>
                <div class="selection-box" id="selection-box" style="display: none;"></div>
                <div class="transform-controls" id="transform-controls">
                    <button class="transform-btn" id="rotate-left-btn" title="向左旋转">
                        <i class="fas fa-undo-alt"></i>
                    </button>
                    <button class="transform-btn" id="rotate-right-btn" title="向右旋转">
                        <i class="fas fa-redo-alt"></i>
                    </button>
                    <button class="transform-btn" id="scale-up-btn" title="放大">
                        <i class="fas fa-search-plus"></i>
                    </button>
                    <button class="transform-btn" id="scale-down-btn" title="缩小">
                        <i class="fas fa-search-minus"></i>
                    </button>
                </div>
                <div class="gesture-hint" id="gesture-hint">
                    双指操作: 旋转/缩放元素
                </div>
            </div>
        </div>
        
        <!-- 右侧属性面板 -->
        <div class="right-panel">
            <div class="panel-title">属性设置</div>
            
            <div id="no-selection-panel" class="no-selection">
                <i class="fas fa-mouse-pointer" style="font-size: 2rem; margin-bottom: 10px; color: #1971c2;"></i>
                <p>请点击画布上的元素以编辑其属性</p>
            </div>
            
            <!-- 粒子发射器属性 -->
            <div id="emitter-properties" style="display: none;">
                <div class="property-group">
                    <h3><i class="fas fa-bullseye"></i> 粒子发射器属性</h3>
                    
                    <div class="property-item">
                        <label for="particle-type">粒子类型</label>
                        <select id="particle-type">
                            <option value="electron">电子 (e⁻)</option>
                            <option value="proton">质子 (p⁺)</option>
                            <option value="alpha">α粒子 (He²⁺)</option>
                            <option value="deuteron">氘核 (d⁺)</option>
                            <option value="triton">氚核 (t⁺)</option>
                            <option value="custom">自定义粒子</option>
                        </select>
                    </div>
                    
                    <div id="custom-particle-properties" style="display: none;">
                        <div class="property-item">
                            <label for="custom-charge">电荷量 (相对单位)</label>
                            <div class="input-with-unit">
                                <input type="number" id="custom-charge" step="1" value="-1">
                                <span class="unit">q</span>
                            </div>
                        </div>
                        
                        <div class="property-item">
                            <label for="custom-mass">质量 (相对单位)</label>
                            <div class="input-with-unit">
                                <input type="number" id="custom-mass" step="1" value="1">
                                <span class="unit">m</span>
                            </div>
                        </div>
                        
                        <div class="property-item">
                            <label for="custom-color">粒子颜色</label>
                            <input type="color" id="custom-color" value="#4dabf7">
                        </div>
                    </div>
                    
                    <div class="property-item">
                        <label for="particle-speed">速度大小</label>
                        <div class="input-with-unit">
                            <input type="number" id="particle-speed" min="1" max="100" step="1" value="3">
                            <span class="unit">m/s</span>
                        </div>
                    </div>
                    
                    <div class="property-item">
                        <label for="particle-angle">速度方向</label>
                        <div class="input-with-unit">
                            <input type="number" id="particle-angle" min="0" max="360" step="1" value="0">
                            <span class="unit">°</span>
                        </div>
                    </div>
                    
                    <div class="property-item">
                        <label for="emission-rate">发射频率</label>
                        <div class="input-with-unit">
                            <input type="number" id="emission-rate" min="0.1" max="60" step="0.1" value="10">
                            <span class="unit">10s/个</span>
                        </div>
                    </div>
                    
                    <div class="property-item">
                        <label for="emitter-size">发射器大小</label>
                        <div class="input-with-unit">
                            <input type="number" id="emitter-size" min="10" max="60" step="1" value="3">
                            <span class="unit">px</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 磁场属性 -->
            <div id="field-properties" style="display: none;">
                <div class="property-group">
                    <h3><i class="fas fa-magnet"></i> 磁场属性</h3>
                    
                    <div class="property-item">
                        <label for="field-shape">磁场形状</label>
                        <select id="field-shape">
                            <option value="rectangle">矩形</option>
                            <option value="circle">圆形</option>
                            <option value="triangle">三角形</option>
                            <option value="single-boundary">单边界</option>
                            <option value="double-boundary">双边界</option>
                        </select>
                    </div>
                    
                    <div class="property-item">
                        <label for="field-direction">磁场方向</label>
                        <select id="field-direction">
                            <option value="out">垂直纸面向外 (⊗)</option>
                            <option value="in">垂直纸面向内 (⊙)</option>
                        </select>
                    </div>
                    
                    <div class="property-item">
                        <label for="field-strength">磁场强度</label>
                        <div class="input-with-unit">
                            <input type="number" id="field-strength" min="0.1" max="10" step="0.1" value="1.0">
                            <span class="unit">B</span>
                        </div>
                    </div>
                    
                    <div class="property-item">
                        <label for="field-width">宽度</label>
                        <div class="input-with-unit">
                            <input type="number" id="field-width" min="50" max="400" step="10" value="150">
                            <span class="unit">px</span>
                        </div>
                    </div>
                    
                    <div class="property-item">
                        <label for="field-height">高度</label>
                        <div class="input-with-unit">
                            <input type="number" id="field-height" min="50" max="400" step="10" value="100">
                            <span class="unit">px</span>
                        </div>
                    </div>
                    
                    <div class="property-item">
                        <label for="field-rotation">旋转角度</label>
                        <div class="input-with-unit">
                            <input type="number" id="field-rotation" min="0" max="360" step="1" value="0">
                            <span class="unit">°</span>
                        </div>
                    </div>
                    
                    <!-- 单边界磁场特殊属性 -->
                    <div id="single-boundary-properties" style="display: none;">
                        <div class="property-item">
                            <label for="boundary-orientation">边界方向</label>
                            <select id="boundary-orientation">
                                <option value="vertical">竖直</option>
                                <option value="horizontal">水平</option>
                            </select>
                        </div>
                        
                        <div class="property-item">
                            <label for="boundary-range">范围</label>
                            <select id="boundary-range">
                                <option value="left">左/上</option>
                                <option value="right">右/下</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 电场属性 -->
            <div id="electric-field-properties" style="display: none;">
                <div class="property-group">
                    <h3><i class="fas fa-bolt"></i> 电场属性</h3>
                    
                    <div class="property-item">
                            <label for="electric-field-shape">电场形状</label>
                            <select id="electric-field-shape">
                                <option value="rectangle">矩形</option>
                            </select>
                        </div>
                    
                    <div class="property-item">
                        <label for="electric-field-direction">电场方向</label>
                        <div class="input-with-unit">
                            <input type="number" id="electric-field-direction" min="0" max="360" step="1" value="0">
                            <span class="unit">°</span>
                        </div>
                        <div style="font-size: 0.8rem; color: #999; margin-top: 5px;">
                            0°为水平向右，90°为竖直向上
                        </div>
                    </div>
                    
                    <div class="property-item">
                        <label for="electric-field-strength">电场强度</label>
                        <div class="input-with-unit">
                            <input type="number" id="electric-field-strength" min="0.1" max="10" step="0.1" value="1.0">
                            <span class="unit">E</span>
                        </div>
                    </div>
                    
                    <div class="property-item">
                        <label for="electric-field-width">宽度</label>
                        <div class="input-with-unit">
                            <input type="number" id="electric-field-width" min="50" max="400" step="10" value="150">
                            <span class="unit">px</span>
                        </div>
                    </div>
                    
                    <div class="property-item">
                        <label for="electric-field-height">高度</label>
                        <div class="input-with-unit">
                            <input type="number" id="electric-field-height" min="50" max="400" step="10" value="100">
                            <span class="unit">px</span>
                        </div>
                    </div>
                    
                    <div class="property-item">
                        <label for="electric-field-rotation">旋转角度</label>
                        <div class="input-with-unit">
                            <input type="number" id="electric-field-rotation" min="0" max="360" step="1" value="0">
                            <span class="unit">°</span>
                        </div>
                    </div>
                    
                    <!-- 单边界电场特殊属性 -->
                    <div id="electric-single-boundary-properties" style="display: none;">
                        <div class="property-item">
                            <label for="electric-boundary-orientation">边界方向</label>
                            <select id="electric-boundary-orientation">
                                <option value="vertical">竖直</option>
                                <option value="horizontal">水平</option>
                            </select>
                        </div>
                        
                        <div class="property-item">
                            <label for="electric-boundary-range">范围</label>
                            <select id="electric-boundary-range">
                                <option value="left">左/上</option>
                                <option value="right">右/下</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 物理信息显示 -->
            <div class="property-group" id="physics-info-panel">
                <h3><i class="fas fa-atom"></i> 物理信息</h3>
                <div id="physics-info">
                    <div class="physics-info-item">
                        <span class="physics-info-label">选定粒子:</span>
                        <span class="physics-info-value" id="selected-particle">无</span>
                    </div>
                    <div class="physics-info-item">
                        <span class="physics-info-label">电荷量:</span>
                        <span class="physics-info-value" id="particle-charge">0 q</span>
                    </div>
                    <div class="physics-info-item">
                        <span class="physics-info-label">质量:</span>
                        <span class="physics-info-value" id="particle-mass">0 m</span>
                    </div>
                    <div class="physics-info-item">
                        <span class="physics-info-label">回旋半径:</span>
                        <span class="physics-info-value" id="gyroradius">0 m</span>
                    </div>
                    <div class="physics-info-item">
                        <span class="physics-info-label">回旋周期:</span>
                        <span class="physics-info-value" id="gyroperiod">0 s</span>
                    </div>
                </div>
            </div>
            
            <!-- 变换控制 -->
            <div class="property-group" id="transform-panel" style="display: none;">
                <h3><i class="fas fa-edit"></i> 变换控制</h3>
                
                <div class="property-item">
                    <label for="element-x">X 坐标</label>
                    <div class="input-with-unit">
                        <input type="number" id="element-x" step="1" value="0">
                        <span class="unit">px</span>
                    </div>
                </div>
                
                <div class="property-item">
                    <label for="element-y">Y 坐标</label>
                    <div class="input-with-unit">
                        <input type="number" id="element-y" step="1" value="0">
                        <span class="unit">px</span>
                    </div>
                </div>
                
                <div class="property-item">
                    <label for="element-rotation">旋转角度</label>
                    <div class="input-with-unit">
                        <input type="number" id="element-rotation" min="0" max="360" step="1" value="0">
                        <span class="unit">°</span>
                    </div>
                </div>
                
                <div class="property-item">
                    <label for="element-scale">缩放比例</label>
                    <div class="input-with-unit">
                        <input type="number" id="element-scale" min="0.1" max="3" step="0.1" value="1.0">
                        <span class="unit">倍</span>
                    </div>
                </div>
                
                <div class="property-item">
                    <button id="delete-element-btn" class="control-button warning" style="width: 100%; margin-top: 10px;">
                        <i class="fas fa-trash-alt"></i> 删除元素
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 底部控制面板 -->
    <div class="control-panel">
        <button id="start-btn" class="control-button primary">
            <i class="fas fa-play"></i> 开始模拟
        </button>
        
        <button id="reset-btn" class="control-button warning">
            <i class="fas fa-redo"></i> 重置
        </button>
        
        <button id="trajectory-btn" class="control-button">
            <i class="fas fa-wave-square"></i> 显示轨迹
        </button>
        
        <button id="clear-btn" class="control-button">
            <i class="fas fa-trash"></i> 清除所有
        </button>
    </div>

    <script>
        // 简化物理常量 - 高中物理阶段简化
        const PHYSICS_CONSTANTS = {
            ELECTRON: {
                name: '电子',
                charge: -1, // 相对单位
                mass: 1,    // 相对单位（实际上电子质量很小，但为简化设为1）
                color: '#4dabf7'
            },
            PROTON: {
                name: '质子',
                charge: 1,  // 相对单位
                mass: 1,    // 相对单位
                color: '#ff6b6b'
            },
            ALPHA: {
                name: 'α粒子',
                charge: 2,  // 相对单位
                mass: 4,    // 相对单位
                color: '#51cf66'
            },
            DEUTERON: {
                name: '氘核',
                charge: 1,  // 相对单位
                mass: 2,    // 相对单位
                color: '#ffd43b'
            },
            TRITON: {
                name: '氚核',
                charge: 1,  // 相对单位
                mass: 3,    // 相对单位
                color: '#cc5de8'
            },
            CUSTOM: {
                name: '自定义粒子',
                charge: -1, // 相对单位
                mass: 1,    // 相对单位
                color: '#4dabf7'
            }
        };

        // 应用状态
        const state = {
            simulationRunning: false,
            showTrajectories: true,
            canvasScale: 1.0,
            canvasOffset: { x: 0, y: 0 },
            isDraggingCanvas: false,
            isDraggingElement: false,
            dragStart: { x: 0, y: 0 },
            selectedElement: null,
            selectedElements: [],
            elements: [],
            particles: [],
            trajectories: [],
            lastFrameTime: 0,
            spacePressed: false,
            simulationStep: 0,
            selection: {
                active: false,
                start: { x: 0, y: 0 },
                end: { x: 0, y: 0 }
            },
            transformControlsVisible: false,
            
            touchStart: {
                x: 0,
                y: 0,
                time: 0,
                distance: 0,
                angle: 0
            },
            multiTouch: {
                active: false,
                initialDistance: 0,
                initialAngle: 0,
                initialScale: 1,
                initialRotation: 0
            },
            
            // 侧边栏状态
            sidebarState: {
                left: {
                    collapsed: false,
                    autoHide: true,
                    hovered: false,
                    lastActivity: Date.now()
                },
                right: {
                    collapsed: false,
                    autoHide: true,
                    hovered: false,
                    lastActivity: Date.now()
                }
            },
            sidebarAutoHideTimer: null,
            
            // 场状态记录（用于检测场是否移动）
            magneticFieldsState: new Map(),
            electricFieldsState: new Map(),
            
            // 已绘制的轨迹圆缓存
            drawnCircles: new Map()
        };

        // 获取DOM元素
        const canvas = document.getElementById('simulation-canvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvas-container');
        const canvasScaleElement = document.getElementById('canvas-scale');
        const particleCountElement = document.getElementById('particle-count');
        const selectionBox = document.getElementById('selection-box');
        const transformControls = document.getElementById('transform-controls');
        const gestureHint = document.getElementById('gesture-hint');
        
        // 左侧面板元素
        const elementCards = document.querySelectorAll('.element-card');
        
        // 右侧面板
        const noSelectionPanel = document.getElementById('no-selection-panel');
        const emitterProperties = document.getElementById('emitter-properties');
        const fieldProperties = document.getElementById('field-properties');
        const electricFieldProperties = document.getElementById('electric-field-properties');
        const transformPanel = document.getElementById('transform-panel');
        const physicsInfoPanel = document.getElementById('physics-info-panel');
        const customParticleProperties = document.getElementById('custom-particle-properties');
        
        // 发射器属性控件
        const particleTypeSelect = document.getElementById('particle-type');
        const particleSpeedInput = document.getElementById('particle-speed');
        const particleAngleInput = document.getElementById('particle-angle');
        const emissionRateInput = document.getElementById('emission-rate');
        const emitterSizeInput = document.getElementById('emitter-size');
        const customChargeInput = document.getElementById('custom-charge');
        const customMassInput = document.getElementById('custom-mass');
        const customColorInput = document.getElementById('custom-color');
        
        // 磁场属性控件
        const fieldShapeSelect = document.getElementById('field-shape');
        const fieldDirectionSelect = document.getElementById('field-direction');
        const fieldStrengthInput = document.getElementById('field-strength');
        const fieldWidthInput = document.getElementById('field-width');
        const fieldHeightInput = document.getElementById('field-height');
        const fieldRotationInput = document.getElementById('field-rotation');
        
        // 单边界磁场特殊属性控件
        const singleBoundaryProperties = document.getElementById('single-boundary-properties');
        const boundaryOrientationSelect = document.getElementById('boundary-orientation');
        const boundaryRangeSelect = document.getElementById('boundary-range');
        
        // 电场属性控件
        const electricFieldShapeSelect = document.getElementById('electric-field-shape');
        const electricFieldDirectionInput = document.getElementById('electric-field-direction');
        const electricFieldStrengthInput = document.getElementById('electric-field-strength');
        const electricFieldWidthInput = document.getElementById('electric-field-width');
        const electricFieldHeightInput = document.getElementById('electric-field-height');
        const electricFieldRotationInput = document.getElementById('electric-field-rotation');
        
        // 单边界电场特殊属性控件
        const electricSingleBoundaryProperties = document.getElementById('electric-single-boundary-properties');
        const electricBoundaryOrientationSelect = document.getElementById('electric-boundary-orientation');
        const electricBoundaryRangeSelect = document.getElementById('electric-boundary-range');
        
        // 变换控制控件
        const elementXInput = document.getElementById('element-x');
        const elementYInput = document.getElementById('element-y');
        const elementRotationInput = document.getElementById('element-rotation');
        const elementScaleInput = document.getElementById('element-scale');
        
        // 物理信息显示
        const selectedParticleElement = document.getElementById('selected-particle');
        const particleChargeElement = document.getElementById('particle-charge');
        const particleMassElement = document.getElementById('particle-mass');
        const gyroradiusElement = document.getElementById('gyroradius');
        const gyroperiodElement = document.getElementById('gyroperiod');
        
        // 控制按钮
        const startButton = document.getElementById('start-btn');
        const resetButton = document.getElementById('reset-btn');
        const trajectoryButton = document.getElementById('trajectory-btn');
        const clearButton = document.getElementById('clear-btn');
        const deleteElementButton = document.getElementById('delete-element-btn');
        
        // 变换按钮
        const rotateLeftBtn = document.getElementById('rotate-left-btn');
        const rotateRightBtn = document.getElementById('rotate-right-btn');
        const scaleUpBtn = document.getElementById('scale-up-btn');
        const scaleDownBtn = document.getElementById('scale-down-btn');
        
        // 悬浮按钮
        const addEmitterBtn = document.getElementById('add-emitter-btn');
        const addFieldBtn = document.getElementById('add-field-btn');
        const addElectricFieldBtn = document.getElementById('add-electric-field-btn');
        
        // 侧边栏元素
        const rightPanel = document.querySelector('.right-panel');

        // 侧边栏自动吸附功能
        function initSidebarAutoHide() {
            // 鼠标悬停事件
            rightPanel.addEventListener('mouseenter', function() {
                updateSidebarActivity('right');
                showSidebar('right');
            });
            
            rightPanel.addEventListener('mouseleave', function() {
                state.sidebarState.right.hovered = false;
                checkSidebarAutoHide();
            });
            
            // 点击事件更新活动时间
            rightPanel.addEventListener('click', function() {
                updateSidebarActivity('right');
            });
            
            // 开始自动隐藏检查
            setInterval(checkSidebarAutoHide, 1000);
        }
        
        // 更新侧边栏活动时间
        function updateSidebarActivity(side) {
            state.sidebarState[side].lastActivity = Date.now();
            state.sidebarState[side].hovered = true;
        }
        
        // 显示侧边栏
        function showSidebar(side) {
            if (side === 'right') {
                rightPanel.classList.remove('collapsed');
                state.sidebarState[side].collapsed = false;
            }
        }
        
        // 隐藏侧边栏
        function hideSidebar(side) {
            if (side === 'right') {
                rightPanel.classList.add('collapsed');
                state.sidebarState[side].collapsed = true;
            }
        }
        
        // 检查侧边栏是否需要自动隐藏
        function checkSidebarAutoHide() {
            const now = Date.now();
            const autoHideDelay = 5000; // 5秒无活动后自动隐藏
            
            // 检查右侧面板
            if (state.sidebarState.right.autoHide && !state.sidebarState.right.hovered && 
                now - state.sidebarState.right.lastActivity > autoHideDelay) {
                hideSidebar('right');
            }
        }
        
        // 初始化画布
        function initCanvas() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // 画布缩放事件
            canvasContainer.addEventListener('wheel', handleCanvasZoom);
            
            // 画布拖拽事件
            canvasContainer.addEventListener('mousedown', handleCanvasMouseDown);
            canvasContainer.addEventListener('mousemove', handleCanvasMouseMove);
            canvasContainer.addEventListener('mouseup', handleCanvasMouseUp);
            canvasContainer.addEventListener('mouseleave', handleCanvasMouseLeave);
            
            // 阻止默认右键菜单
            canvasContainer.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });
            
            // 双击事件已移除
            
            // 触摸事件支持（iPad适配）
            canvasContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvasContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvasContainer.addEventListener('touchend', handleTouchEnd);
            canvasContainer.addEventListener('touchcancel', handleTouchEnd);
            
            // 键盘事件
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // 初始化侧边栏自动隐藏功能
            initSidebarAutoHide();
            
            // 初始绘制
            draw();
        }

        // 处理键盘按下
        function handleKeyDown(e) {
            if (e.code === 'Space') {
                e.preventDefault();
                state.spacePressed = true;
                canvasContainer.style.cursor = 'grab';
            }
        }

        // 处理键盘释放
        function handleKeyUp(e) {
            if (e.code === 'Space') {
                state.spacePressed = false;
                canvasContainer.style.cursor = 'default';
            }
        }

        // 调整画布大小
        function resizeCanvas() {
            const containerRect = canvasContainer.getBoundingClientRect();
            canvas.width = containerRect.width;
            canvas.height = containerRect.height;
            
            // 初始偏移，使内容居中
            if (state.elements.length === 0) {
                state.canvasOffset.x = canvas.width / 2 - 200;
                state.canvasOffset.y = canvas.height / 2 - 150;
            }
            
            draw();
        }

        // 处理画布缩放
        function handleCanvasZoom(e) {
            e.preventDefault();
            
            const zoomIntensity = 0.1;
            const mouseX = e.clientX - canvasContainer.getBoundingClientRect().left;
            const mouseY = e.clientY - canvasContainer.getBoundingClientRect().top;
            
            // 计算鼠标在画布空间中的位置
            const worldX = (mouseX - state.canvasOffset.x) / state.canvasScale;
            const worldY = (mouseY - state.canvasOffset.y) / state.canvasScale;
            
            // 更新缩放比例
            if (e.deltaY < 0) {
                state.canvasScale *= (1 + zoomIntensity);
            } else {
                state.canvasScale *= (1 - zoomIntensity);
            }
            
            // 限制缩放范围
            state.canvasScale = Math.max(0.1, Math.min(5, state.canvasScale));
            
            // 调整偏移量以保持鼠标位置不变
            state.canvasOffset.x = mouseX - worldX * state.canvasScale;
            state.canvasOffset.y = mouseY - worldY * state.canvasScale;
            
            canvasScaleElement.textContent = `${Math.round(state.canvasScale * 100)}%`;
            draw();
        }

        // 处理鼠标按下事件
        function handleCanvasMouseDown(e) {
            const rect = canvasContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // 计算画布空间中的坐标
            const worldX = (x - state.canvasOffset.x) / state.canvasScale;
            const worldY = (y - state.canvasOffset.y) / state.canvasScale;
            
            // 检查是否点击了元素
            let clickedElement = null;
            
            for (const element of state.elements) {
                if (isPointInElement(worldX, worldY, element)) {
                    clickedElement = element;
                    break;
                }
            }
            
            // 处理右键点击
            if (e.button === 2) {
                e.preventDefault(); // 阻止默认右键菜单
                // 开始拖拽画布
                state.isDraggingCanvas = true;
                state.dragStart.x = e.clientX - state.canvasOffset.x;
                state.dragStart.y = e.clientY - state.canvasOffset.y;
                canvasContainer.style.cursor = 'grabbing';
                return;
            }
            
            if (clickedElement) {
                // 如果按住Ctrl键，可以多选
                if (e.ctrlKey) {
                    // 切换元素的选择状态
                    const index = state.selectedElements.indexOf(clickedElement);
                    if (index === -1) {
                        state.selectedElements.push(clickedElement);
                        state.selectedElement = clickedElement;
                    } else {
                        state.selectedElements.splice(index, 1);
                        state.selectedElement = state.selectedElements.length > 0 ? state.selectedElements[state.selectedElements.length - 1] : null;
                    }
                } else {
                    // 如果已经选中了元素，并且按住Shift键，添加到选区
                    if (e.shiftKey && state.selectedElement && !state.selectedElements.includes(clickedElement)) {
                        state.selectedElements.push(clickedElement);
                    } else if (!e.shiftKey && !state.selectedElements.includes(clickedElement)) {
                        // 单选
                        state.selectedElements = [clickedElement];
                        state.selectedElement = clickedElement;
                    }
                }
                
                // 开始拖拽元素
                state.isDraggingElement = true;
                state.dragStart.x = e.clientX;
                state.dragStart.y = e.clientY;
                state.dragStart.elementX = clickedElement.x;
                state.dragStart.elementY = clickedElement.y;
                
                canvasContainer.style.cursor = 'grabbing';
                
                // 更新属性面板
                updatePropertiesPanel();
                
                // 隐藏变换控制按钮（将在鼠标释放后显示）
                transformControls.classList.remove('active');
            } else if (state.spacePressed) {
                // 按住空格键拖拽画布
                state.isDraggingCanvas = true;
                state.dragStart.x = e.clientX - state.canvasOffset.x;
                state.dragStart.y = e.clientY - state.canvasOffset.y;
                canvasContainer.style.cursor = 'grabbing';
            } else {
                // 点击空白处，开始框选
                state.selection.active = true;
                state.selection.start = {
                    x: e.clientX,
                    y: e.clientY
                };
                state.selection.end = {
                    x: e.clientX,
                    y: e.clientY
                };
                
                // 显示选择框
                selectionBox.style.display = 'block';
                updateSelectionBox();
                
                // 取消之前的选择
                if (!e.ctrlKey && !e.shiftKey) {
                    state.selectedElements = [];
                    state.selectedElement = null;
                }
                
                // 隐藏变换控制按钮
                transformControls.classList.remove('active');
                gestureHint.classList.remove('active');
                
                // 更新属性面板
                updatePropertiesPanel();
            }
            
            draw();
        }

        // 处理鼠标移动事件
        function handleCanvasMouseMove(e) {
            const rect = canvasContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // 计算画布空间中的坐标
            const worldX = (x - state.canvasOffset.x) / state.canvasScale;
            const worldY = (y - state.canvasOffset.y) / state.canvasScale;
            
            if (state.isDraggingElement && state.selectedElements.length > 0) {
                // 拖拽所有选中的元素
                const dx = (e.clientX - state.dragStart.x) / state.canvasScale;
                const dy = (e.clientY - state.dragStart.y) / state.canvasScale;
                
                // 移动所有选中元素
                state.selectedElements.forEach(element => {
                    // 如果是第一次移动这个元素，记录其初始位置
                    if (!element.initialDragX) {
                        element.initialDragX = element.x;
                        element.initialDragY = element.y;
                    }
                    
                    element.x = element.initialDragX + dx;
                    element.y = element.initialDragY + dy;
                });
                
                // 更新变换控制面板
                if (state.selectedElement) {
                    updateTransformControls();
                }
                
                draw();
            } else if (state.isDraggingCanvas) {
                // 拖拽画布
                state.canvasOffset.x = e.clientX - state.dragStart.x;
                state.canvasOffset.y = e.clientY - state.dragStart.y;
                draw();
            } else if (state.selection.active) {
                // 更新框选区域
                state.selection.end = {
                    x: e.clientX,
                    y: e.clientY
                };
                updateSelectionBox();
            } else {
                // 检查鼠标是否在元素上，改变光标样式
                let overElement = false;
                for (const element of state.elements) {
                    if (isPointInElement(worldX, worldY, element)) {
                        overElement = true;
                        break;
                    }
                }
                
                canvasContainer.style.cursor = overElement ? 'move' : 'default';
            }
        }

        // 处理鼠标释放事件
        function handleCanvasMouseUp() {
            // 结束拖拽元素时清除初始位置记录
            if (state.isDraggingElement) {
                state.selectedElements.forEach(element => {
                    delete element.initialDragX;
                    delete element.initialDragY;
                });
            }
            
            state.isDraggingElement = false;
            state.isDraggingCanvas = false;
            
            // 完成框选
            if (state.selection.active) {
                const rect = canvasContainer.getBoundingClientRect();
                
                // 计算框选区域在屏幕空间中的坐标
                const selectionRect = {
                    left: Math.min(state.selection.start.x, state.selection.end.x) - rect.left,
                    top: Math.min(state.selection.start.y, state.selection.end.y) - rect.top,
                    right: Math.max(state.selection.start.x, state.selection.end.x) - rect.left,
                    bottom: Math.max(state.selection.start.y, state.selection.end.y) - rect.top
                };
                
                // 将选择区域转换到画布空间
                const worldRect = {
                    left: (selectionRect.left - state.canvasOffset.x) / state.canvasScale,
                    top: (selectionRect.top - state.canvasOffset.y) / state.canvasScale,
                    right: (selectionRect.right - state.canvasOffset.x) / state.canvasScale,
                    bottom: (selectionRect.bottom - state.canvasOffset.y) / state.canvasScale
                };
                
                // 选择框内的元素
                const selected = [];
                
                for (const element of state.elements) {
                    if (isElementInSelection(element, worldRect)) {
                        selected.push(element);
                    }
                }
                
                // 更新选择状态
                if (selected.length > 0) {
                    state.selectedElements = selected;
                    state.selectedElement = selected[selected.length - 1];
                    
                    // 显示变换控制按钮
                    transformControls.classList.add('active');
                    gestureHint.classList.add('active');
                } else {
                    // 隐藏变换控制按钮
                    transformControls.classList.remove('active');
                    gestureHint.classList.remove('active');
                }
                
                // 结束框选
                state.selection.active = false;
                selectionBox.style.display = 'none';
                
                // 更新属性面板
                updatePropertiesPanel();
                draw();
            } else if (state.selectedElements.length > 0) {
                // 如果已经选择了元素，显示变换控制按钮
                transformControls.classList.add('active');
                gestureHint.classList.add('active');
            }
            
            canvasContainer.style.cursor = 'default';
        }

        // 处理鼠标离开事件
        function handleCanvasMouseLeave() {
            state.isDraggingElement = false;
            state.isDraggingCanvas = false;
            
            // 结束框选
            if (state.selection.active) {
                state.selection.active = false;
                selectionBox.style.display = 'none';
            }
            
            canvasContainer.style.cursor = 'default';
        }
        
        // 触摸事件处理（iPad适配）
        function handleTouchStart(e) {
            e.preventDefault();
            
            const touches = e.touches;
            const rect = canvasContainer.getBoundingClientRect();
            
            if (touches.length === 1) {
                // 单指触摸
                const touch = touches[0];
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                // 计算画布空间中的坐标
                const worldX = (x - state.canvasOffset.x) / state.canvasScale;
                const worldY = (y - state.canvasOffset.y) / state.canvasScale;
                
                // 检查是否触摸了元素
                let touchedElement = null;
                
                for (const element of state.elements) {
                    if (isPointInElement(worldX, worldY, element)) {
                        touchedElement = element;
                        break;
                    }
                }
                
                if (touchedElement) {
                    // 选择元素
                    if (!state.selectedElements.includes(touchedElement)) {
                        state.selectedElements = [touchedElement];
                        state.selectedElement = touchedElement;
                    }
                    
                    // 开始拖拽元素
                    state.isDraggingElement = true;
                    state.dragStart.x = touch.clientX;
                    state.dragStart.y = touch.clientY;
                    state.dragStart.elementX = touchedElement.x;
                    state.dragStart.elementY = touchedElement.y;
                    
                    // 更新属性面板
                    updatePropertiesPanel();
                    
                    // 显示变换控制按钮
                    transformControls.classList.add('active');
                    gestureHint.classList.add('active');
                } else {
                    // 触摸空白处，开始拖动画布
                    state.isDraggingCanvas = true;
                    state.dragStart.x = touch.clientX;
                    state.dragStart.y = touch.clientY;
                    state.dragStart.canvasOffsetX = state.canvasOffset.x;
                    state.dragStart.canvasOffsetY = state.canvasOffset.y;
                    
                    // 取消之前的选择
                    state.selectedElements = [];
                    state.selectedElement = null;
                    
                    // 隐藏变换控制按钮
                    transformControls.classList.remove('active');
                    gestureHint.classList.remove('active');
                    
                    // 更新属性面板
                    updatePropertiesPanel();
                }
                
                // 双击事件检测已移除
                
            } else if (touches.length === 2) {
                // 双指触摸
                const touch1 = touches[0];
                const touch2 = touches[1];
                
                if (state.selectedElements.length > 0) {
                    // 有选中元素，开始旋转/缩放元素
                    // 计算两点距离和角度
                    const dx = touch2.clientX - touch1.clientX;
                    const dy = touch2.clientY - touch1.clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    state.multiTouch.active = true;
                    state.multiTouch.initialDistance = distance;
                    state.multiTouch.initialAngle = angle;
                    state.multiTouch.initialScale = state.selectedElement ? state.selectedElement.scale : 1;
                    state.multiTouch.initialRotation = state.selectedElement ? state.selectedElement.rotation : 0;
                    
                    // 隐藏变换控制按钮
                    transformControls.classList.remove('active');
                    gestureHint.classList.add('active');
                } else {
                    // 无选中元素，开始双指平移/缩放画布
                    // 计算两点距离和中点
                    const dx = touch2.clientX - touch1.clientX;
                    const dy = touch2.clientY - touch1.clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const midX = (touch1.clientX + touch2.clientX) / 2;
                    const midY = (touch1.clientY + touch2.clientY) / 2;
                    
                    state.multiTouch.active = true;
                    state.multiTouch.initialDistance = distance;
                    state.multiTouch.initialScale = state.canvasScale;
                    state.multiTouch.initialCanvasOffset = { ...state.canvasOffset };
                    state.multiTouch.initialMidpoint = { x: midX, y: midY };
                    state.isDraggingCanvas = true;
                    
                    // 隐藏变换控制按钮
                    transformControls.classList.remove('active');
                    gestureHint.classList.remove('active');
                }
            }
            
            draw();
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            
            const touches = e.touches;
            const rect = canvasContainer.getBoundingClientRect();
            
            if (touches.length === 1 && state.isDraggingElement) {
                // 单指拖拽元素
                const touch = touches[0];
                const dx = (touch.clientX - state.dragStart.x) / state.canvasScale;
                const dy = (touch.clientY - state.dragStart.y) / state.canvasScale;
                
                // 移动所有选中元素
                state.selectedElements.forEach(element => {
                    if (!element.initialDragX) {
                        element.initialDragX = element.x;
                        element.initialDragY = element.y;
                    }
                    
                    element.x = element.initialDragX + dx;
                    element.y = element.initialDragY + dy;
                });
                
                // 更新变换控制面板
                if (state.selectedElement) {
                    updateTransformControls();
                }
                
                draw();
            } else if (touches.length === 1 && state.isDraggingCanvas) {
                // 单指拖动画布
                const touch = touches[0];
                
                // 计算偏移量
                state.canvasOffset.x = state.dragStart.canvasOffsetX + (touch.clientX - state.dragStart.x);
                state.canvasOffset.y = state.dragStart.canvasOffsetY + (touch.clientY - state.dragStart.y);
                
                draw();
            } else if (touches.length === 2 && state.multiTouch.active) {
                const touch1 = touches[0];
                const touch2 = touches[1];
                
                if (state.selectedElements.length > 0) {
                    // 双指旋转/缩放选中元素
                    // 计算当前两点距离和角度
                    const dx = touch2.clientX - touch1.clientX;
                    const dy = touch2.clientY - touch1.clientY;
                    const currentDistance = Math.sqrt(dx * dx + dy * dy);
                    const currentAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    // 计算缩放比例
                    const scaleChange = currentDistance / state.multiTouch.initialDistance;
                    
                    // 计算旋转角度变化
                    const angleChange = currentAngle - state.multiTouch.initialAngle;
                    
                    // 应用变换到所有选中元素
                    state.selectedElements.forEach(element => {
                        // 缩放
                        element.scale = Math.max(0.1, Math.min(3, state.multiTouch.initialScale * scaleChange));
                        
                        // 旋转
                        element.rotation = (state.multiTouch.initialRotation + angleChange) % 360;
                        if (element.rotation < 0) element.rotation += 360;
                    });
                    
                    // 更新变换控制面板
                    updateTransformControls();
                } else {
                    // 双指平移/缩放画布
                    // 计算当前两点距离和中点
                    const dx = touch2.clientX - touch1.clientX;
                    const dy = touch2.clientY - touch1.clientY;
                    const currentDistance = Math.sqrt(dx * dx + dy * dy);
                    const currentMidX = (touch1.clientX + touch2.clientX) / 2;
                    const currentMidY = (touch1.clientY + touch2.clientY) / 2;
                    
                    // 计算缩放比例
                    const scaleChange = currentDistance / state.multiTouch.initialDistance;
                    const newScale = Math.max(0.1, Math.min(5, state.multiTouch.initialScale * scaleChange));
                    
                    // 计算中点偏移
                    const midOffsetX = currentMidX - state.multiTouch.initialMidpoint.x;
                    const midOffsetY = currentMidY - state.multiTouch.initialMidpoint.y;
                    
                    // 计算画布缩放中心调整
                    const scaleRatio = newScale / state.multiTouch.initialScale;
                    const canvasAdjustX = state.multiTouch.initialMidpoint.x - state.multiTouch.initialCanvasOffset.x;
                    const canvasAdjustY = state.multiTouch.initialMidpoint.y - state.multiTouch.initialCanvasOffset.y;
                    const scaleCenterOffsetX = canvasAdjustX * (scaleRatio - 1);
                    const scaleCenterOffsetY = canvasAdjustY * (scaleRatio - 1);
                    
                    // 更新画布缩放和偏移
                    state.canvasScale = newScale;
                    state.canvasOffset.x = state.multiTouch.initialCanvasOffset.x - scaleCenterOffsetX + midOffsetX;
                    state.canvasOffset.y = state.multiTouch.initialCanvasOffset.y - scaleCenterOffsetY + midOffsetY;
                    
                    // 更新缩放显示
                    canvasScaleElement.textContent = `${Math.round(state.canvasScale * 100)}%`;
                }
                
                draw();
            }
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            
            // 结束拖拽元素时清除初始位置记录
            if (state.isDraggingElement) {
                state.selectedElements.forEach(element => {
                    delete element.initialDragX;
                    delete element.initialDragY;
                });
            }
            
            state.isDraggingElement = false;
            state.isDraggingCanvas = false;
            state.multiTouch.active = false;
            
            // 完成框选
            if (state.selection.active) {
                const rect = canvasContainer.getBoundingClientRect();
                
                // 计算框选区域在屏幕空间中的坐标
                const selectionRect = {
                    left: Math.min(state.selection.start.x, state.selection.end.x) - rect.left,
                    top: Math.min(state.selection.start.y, state.selection.end.y) - rect.top,
                    right: Math.max(state.selection.start.x, state.selection.end.x) - rect.left,
                    bottom: Math.max(state.selection.start.y, state.selection.end.y) - rect.top
                };
                
                // 将选择区域转换到画布空间
                const worldRect = {
                    left: (selectionRect.left - state.canvasOffset.x) / state.canvasScale,
                    top: (selectionRect.top - state.canvasOffset.y) / state.canvasScale,
                    right: (selectionRect.right - state.canvasOffset.x) / state.canvasScale,
                    bottom: (selectionRect.bottom - state.canvasOffset.y) / state.canvasScale
                };
                
                // 选择框内的元素
                const selected = [];
                
                for (const element of state.elements) {
                    if (isElementInSelection(element, worldRect)) {
                        selected.push(element);
                    }
                }
                
                // 更新选择状态
                if (selected.length > 0) {
                    state.selectedElements = selected;
                    state.selectedElement = selected[selected.length - 1];
                    
                    // 显示变换控制按钮
                    transformControls.classList.add('active');
                    gestureHint.classList.add('active');
                } else {
                    // 隐藏变换控制按钮
                    transformControls.classList.remove('active');
                    gestureHint.classList.remove('active');
                }
                
                // 结束框选
                state.selection.active = false;
                selectionBox.style.display = 'none';
                
                // 更新属性面板
                updatePropertiesPanel();
                draw();
            } else if (state.selectedElements.length > 0) {
                // 如果已经选择了元素，显示变换控制按钮
                transformControls.classList.add('active');
                gestureHint.classList.add('active');
            }
        }

        // 检查点是否在元素内
        function isPointInElement(x, y, element) {
            // 将点转换到元素局部坐标系
            const dx = x - element.x;
            const dy = y - element.y;
            
            // 考虑旋转
            const angle = element.rotation * Math.PI / 180;
            const cosAngle = Math.cos(angle);
            const sinAngle = Math.sin(angle);
            const rotatedX = dx * cosAngle + dy * sinAngle;
            const rotatedY = -dx * sinAngle + dy * cosAngle;
            
            // 考虑缩放
            const scaledX = rotatedX / element.scale;
            const scaledY = rotatedY / element.scale;
            
            if (element.type === 'particle-emitter') {
                // 圆形发射器
                const distance = Math.sqrt(scaledX**2 + scaledY**2);
                return distance <= element.radius;
            } else if (element.type === 'magnetic-field' || element.type === 'electric-field') {
                // 根据形状判断
                if (element.shape === 'rectangle') {
                    return Math.abs(scaledX) <= element.width/2 && Math.abs(scaledY) <= element.height/2;
                } else if (element.shape === 'circle') {
                    const distance = Math.sqrt(scaledX**2 + scaledY**2);
                    return distance <= element.width/2;
                } else if (element.shape === 'triangle') {
                    // 三角形检测（顶点在上，底边在下）
                    const halfHeight = element.height/2;
                    const halfWidth = element.width/2;
                    
                    // 三角形的三个顶点（局部坐标系）
                    const vertex1 = { x: 0, y: -halfHeight }; // 顶部顶点
                    const vertex2 = { x: -halfWidth, y: halfHeight }; // 左下顶点
                    const vertex3 = { x: halfWidth, y: halfHeight }; // 右下顶点
                    
                    // 使用Barycentric坐标法判断点是否在三角形内
                    const area = element.width * element.height / 2;
                    
                    // 计算三个子三角形的面积
                    const area1 = Math.abs((vertex1.x*(vertex2.y - vertex3.y) + vertex2.x*(vertex3.y - vertex1.y) + vertex3.x*(vertex1.y - vertex2.y)) / 2);
                    const area2 = Math.abs((scaledX*(vertex2.y - vertex3.y) + vertex2.x*(vertex3.y - scaledY) + vertex3.x*(scaledY - vertex2.y)) / 2);
                    const area3 = Math.abs((vertex1.x*(scaledY - vertex3.y) + scaledX*(vertex3.y - vertex1.y) + vertex3.x*(vertex1.y - scaledY)) / 2);
                    const area4 = Math.abs((vertex1.x*(vertex2.y - scaledY) + vertex2.x*(scaledY - vertex1.y) + scaledX*(vertex1.y - vertex2.y)) / 2);
                    
                    // 如果三个子三角形面积之和等于原三角形面积，则点在三角形内
                    return Math.abs(area2 + area3 + area4 - area1) < 0.1;
                } else if (element.shape === 'single-boundary') {
                    const orientation = element.boundaryOrientation || 'vertical';
                    
                    // 单边界：检查点是否接近边界线
                    if (orientation === 'vertical') {
                        // 竖直边界：检查x坐标是否接近0
                        return Math.abs(scaledX) < 5;
                    } else {
                        // 水平边界：检查y坐标是否接近0
                        return Math.abs(scaledY) < 5;
                    }
                } else if (element.shape === 'double-boundary') {
                    // 双边界：检查点是否接近边界线或在边界之间
                    const topY = -element.height/2;
                    const bottomY = element.height/2;
                    
                    // 检查是否接近上边界线
                    if (Math.abs(scaledY - topY) < 5) {
                        return true;
                    }
                    
                    // 检查是否接近下边界线
                    if (Math.abs(scaledY - bottomY) < 5) {
                        return true;
                    }
                    
                    // 检查是否在两个边界之间
                    return scaledY > topY && scaledY < bottomY;
                }
            }
            
            return false;
        }

        // 检查元素是否在选择框内
        function isElementInSelection(element, worldRect) {
            // 计算元素的边界框
            let elementBounds;
            
            if (element.type === 'particle-emitter') {
                const radius = element.radius * element.scale;
                elementBounds = {
                    left: element.x - radius,
                    right: element.x + radius,
                    top: element.y - radius,
                    bottom: element.y + radius
                };
            } else if (element.type === 'magnetic-field' || element.type === 'electric-field') {
                // 考虑旋转和缩放
                const halfWidth = element.width * element.scale / 2;
                const halfHeight = element.height * element.scale / 2;
                
                // 计算旋转后的边界框
                const angle = element.rotation * Math.PI / 180;
                const cosAngle = Math.cos(angle);
                const sinAngle = Math.sin(angle);
                
                const points = [
                    { x: -halfWidth, y: -halfHeight },
                    { x: halfWidth, y: -halfHeight },
                    { x: halfWidth, y: halfHeight },
                    { x: -halfWidth, y: halfHeight }
                ];
                
                // 旋转点并找到边界
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                points.forEach(point => {
                    const rotatedX = point.x * cosAngle - point.y * sinAngle + element.x;
                    const rotatedY = point.x * sinAngle + point.y * cosAngle + element.y;
                    
                    minX = Math.min(minX, rotatedX);
                    maxX = Math.max(maxX, rotatedX);
                    minY = Math.min(minY, rotatedY);
                    maxY = Math.max(maxY, rotatedY);
                });
                
                elementBounds = {
                    left: minX,
                    right: maxX,
                    top: minY,
                    bottom: maxY
                };
            }
            
            // 检查边界框是否在选择框内
            return (
                elementBounds.left >= worldRect.left &&
                elementBounds.right <= worldRect.right &&
                elementBounds.top >= worldRect.top &&
                elementBounds.bottom <= worldRect.bottom
            );
        }

        // 更新选择框显示
        function updateSelectionBox() {
            const rect = canvasContainer.getBoundingClientRect();
            const left = Math.min(state.selection.start.x, state.selection.end.x) - rect.left;
            const top = Math.min(state.selection.start.y, state.selection.end.y) - rect.top;
            const width = Math.abs(state.selection.end.x - state.selection.start.x);
            const height = Math.abs(state.selection.end.y - state.selection.start.y);
            
            selectionBox.style.left = `${left}px`;
            selectionBox.style.top = `${top}px`;
            selectionBox.style.width = `${width}px`;
            selectionBox.style.height = `${height}px`;
        }

        // 检查场是否发生变化
        function checkFieldsChanged() {
            const magneticFields = state.elements.filter(el => el.type === 'magnetic-field');
            const electricFields = state.elements.filter(el => el.type === 'electric-field');
            let fieldsChanged = false;
            
            // 检查每个磁场的状态
            magneticFields.forEach(field => {
                const fieldKey = `${field.id}_${field.x}_${field.y}_${field.rotation}_${field.scale}_${field.width}_${field.height}`;
                
                if (!state.magneticFieldsState.has(field.id) || state.magneticFieldsState.get(field.id) !== fieldKey) {
                    fieldsChanged = true;
                    state.magneticFieldsState.set(field.id, fieldKey);
                }
            });
            
            // 检查每个电场的状态
            electricFields.forEach(field => {
                const fieldKey = `${field.id}_${field.x}_${field.y}_${field.rotation}_${field.scale}_${field.width}_${field.height}`;
                
                if (!state.electricFieldsState.has(field.id) || state.electricFieldsState.get(field.id) !== fieldKey) {
                    fieldsChanged = true;
                    state.electricFieldsState.set(field.id, fieldKey);
                }
            });
            
            // 如果场发生变化，清除所有粒子的轨迹圆
            if (fieldsChanged) {
                state.particles.forEach(particle => {
                    particle.circleCenter = null;
                    particle.circleRadius = 0;
                    particle.entryPoint = null;
                    particle.exitPoint = null;
                    particle.inMagneticField = false;
                    particle.inElectricField = false;
                    particle.electricAcceleration = { x: 0, y: 0 };
                    particle.electricEntryPoint = null;
                    particle.electricExitPoint = null;
                    particle.velocityPerpendicular = null;
                    particle.velocityParallel = null;
                });
                
                // 清除已绘制的轨迹圆缓存
                state.drawnCircles.clear();
            }
        }

        // 绘制函数
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 保存当前画布状态
            ctx.save();
            
            // 应用缩放和平移
            ctx.translate(state.canvasOffset.x, state.canvasOffset.y);
            ctx.scale(state.canvasScale, state.canvasScale);
            
            // 绘制网格背景
            drawGrid();
            
            // 绘制所有元素
            state.elements.forEach(element => {
                drawElement(element);
            });
            
            // 绘制所有轨迹
            if (state.showTrajectories) {
                state.trajectories.forEach(trajectory => {
                    drawTrajectory(trajectory);
                });
            }
            
            // 绘制轨迹圆（紫色虚线）- 只绘制唯一的圆
            state.drawnCircles.clear(); // 清空之前的缓存
            const uniqueCircles = new Map(); // 用于存储唯一的圆
            
            state.particles.forEach(particle => {
                if (particle.circleCenter && particle.circleRadius > 0) {
                    const circleKey = `${particle.circleCenter.x.toFixed(2)},${particle.circleCenter.y.toFixed(2)},${particle.circleRadius.toFixed(2)}`;
                    
                    if (!uniqueCircles.has(circleKey)) {
                        uniqueCircles.set(circleKey, particle);
                        state.drawnCircles.set(circleKey, particle);
                        
                        // 绘制紫色虚线圆
                        ctx.save();
                        ctx.strokeStyle = '#9c27b0'; // 紫色
                        ctx.lineWidth = 1;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.arc(particle.circleCenter.x, particle.circleCenter.y, particle.circleRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // 绘制圆心（紫色小点）
                        ctx.fillStyle = '#9c27b0';
                        ctx.beginPath();
                        ctx.arc(particle.circleCenter.x, particle.circleCenter.y, 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }
            });
            
            // 绘制所有粒子
            state.particles.forEach(particle => {
                drawParticle(particle);
                
                // 绘制每个粒子的特殊标记（进入点、退出点、圆心角等）
                if (particle.circleCenter && particle.circleRadius > 0) {
                    // 绘制进入点（红色）
                    if (particle.entryPoint) {
                        ctx.save();
                        ctx.fillStyle = '#ff5252';
                        ctx.beginPath();
                        ctx.arc(particle.entryPoint.x, particle.entryPoint.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                    
                    // 绘制退出点（红色）
                    if (particle.exitPoint) {
                        ctx.save();
                        ctx.fillStyle = '#ff5252';
                        ctx.beginPath();
                        ctx.arc(particle.exitPoint.x, particle.exitPoint.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                    
                    // 绘制圆心角和theta标记（红色）
                    if (particle.entryPoint) {
                        ctx.save();
                        ctx.strokeStyle = '#ff5252';
                        ctx.fillStyle = '#ff5252';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([]);
                        
                        // 确定结束点：如果已退出磁场则使用退出点，否则使用当前位置
                        const endPoint = particle.exitPoint || particle;
                        
                        // 绘制进入点半径线
                        ctx.beginPath();
                        ctx.moveTo(particle.circleCenter.x, particle.circleCenter.y);
                        ctx.lineTo(particle.entryPoint.x, particle.entryPoint.y);
                        ctx.stroke();
                        
                        // 绘制结束点半径线
                        ctx.beginPath();
                        ctx.moveTo(particle.circleCenter.x, particle.circleCenter.y);
                        ctx.lineTo(endPoint.x, endPoint.y);
                        ctx.stroke();
                        
                        // 绘制theta角弧
                        const startAngle = Math.atan2(particle.entryPoint.y - particle.circleCenter.y, particle.entryPoint.x - particle.circleCenter.x);
                        const endAngle = Math.atan2(endPoint.y - particle.circleCenter.y, endPoint.x - particle.circleCenter.x);
                        const arcRadius = 15;
                        
                        ctx.beginPath();
                        ctx.arc(particle.circleCenter.x, particle.circleCenter.y, arcRadius, startAngle, endAngle, particle.angularSpeed > 0 ? false : true);
                        ctx.stroke();
                        
                        // 绘制theta标签
                        const midAngle = (startAngle + endAngle) / 2;
                        const labelX = particle.circleCenter.x + Math.cos(midAngle) * (arcRadius + 10);
                        const labelY = particle.circleCenter.y + Math.sin(midAngle) * (arcRadius + 10);
                        
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('θ', labelX, labelY);
                        
                        ctx.restore();
                    }
                }
            });
            
            
            ctx.restore();
        }

        // 绘制网格背景
        function drawGrid() {
            const gridSize = 50;
            const gridColor = '#121212';
            const gridLineColor = '#333';
            
            // 计算可见区域
            const visibleLeft = -state.canvasOffset.x / state.canvasScale;
            const visibleTop = -state.canvasOffset.y / state.canvasScale;
            const visibleRight = (canvas.width - state.canvasOffset.x) / state.canvasScale;
            const visibleBottom = (canvas.height - state.canvasOffset.y) / state.canvasScale;
            
            // 绘制网格背景
            ctx.fillStyle = gridColor;
            ctx.fillRect(visibleLeft, visibleTop, visibleRight - visibleLeft, visibleBottom - visibleTop);
            
            // 绘制网格线
            ctx.strokeStyle = gridLineColor;
            ctx.lineWidth = 1;
            
            // 垂直线
            const startX = Math.floor(visibleLeft / gridSize) * gridSize;
            const endX = Math.ceil(visibleRight / gridSize) * gridSize;
            
            for (let x = startX; x <= endX; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, visibleTop);
                ctx.lineTo(x, visibleBottom);
                ctx.stroke();
            }
            
            // 水平线
            const startY = Math.floor(visibleTop / gridSize) * gridSize;
            const endY = Math.ceil(visibleBottom / gridSize) * gridSize;
            
            for (let y = startY; y <= endY; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(visibleLeft, y);
                ctx.lineTo(visibleRight, y);
                ctx.stroke();
            }
            
            // 绘制坐标轴
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            
            // X轴
            ctx.beginPath();
            ctx.moveTo(visibleLeft, 0);
            ctx.lineTo(visibleRight, 0);
            ctx.stroke();
            
            // Y轴
            ctx.beginPath();
            ctx.moveTo(0, visibleTop);
            ctx.lineTo(0, visibleBottom);
            ctx.stroke();
            
            // 绘制坐标轴箭头和标签
            ctx.fillStyle = '#999';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            // X轴箭头和标签
            ctx.beginPath();
            ctx.moveTo(visibleRight - 10, -5);
            ctx.lineTo(visibleRight, 0);
            ctx.lineTo(visibleRight - 10, 5);
            ctx.fill();
            ctx.fillText('X', visibleRight - 15, 10);
            
            // Y轴箭头和标签
            ctx.beginPath();
            ctx.moveTo(-5, visibleTop + 10);
            ctx.lineTo(0, visibleTop);
            ctx.lineTo(5, visibleTop + 10);
            ctx.fill();
            ctx.fillText('Y', 15, visibleTop + 5);
        }

        // 绘制元素
        function drawElement(element) {
            ctx.save();
            ctx.translate(element.x, element.y);
            ctx.rotate(element.rotation * Math.PI / 180);
            ctx.scale(element.scale, element.scale);
            
            if (element.type === 'particle-emitter') {
                // 绘制粒子发射器（黄色区域）
                ctx.fillStyle = 'rgba(255, 193, 7, 0.3)';
                ctx.strokeStyle = '#ffc107';
                ctx.lineWidth = 1;
                
                ctx.beginPath();
                ctx.arc(0, 0, element.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // 绘制方向箭头（黄色）
                ctx.strokeStyle = '#ffc107';
                ctx.fillStyle = '#ffc107';
                ctx.lineWidth = 0.5;
                
                ctx.beginPath();
                ctx.moveTo(0, 0);
                const angleRad = element.angle * Math.PI / 180;
                const arrowLength = element.radius * 5;
                ctx.lineTo(
                    Math.cos(angleRad) * arrowLength,
                    -Math.sin(angleRad) * arrowLength
                );
                ctx.stroke();
                
                // 绘制箭头头部
                ctx.beginPath();
                const arrowX = Math.cos(angleRad) * arrowLength;
                const arrowY = -Math.sin(angleRad) * arrowLength;
                ctx.translate(arrowX, arrowY);
                ctx.rotate(angleRad);
                ctx.moveTo(0, 0);
                ctx.lineTo(-8, -3);
                ctx.lineTo(-8, 3);
                ctx.closePath();
                ctx.fill();
                
            } else if (element.type === 'magnetic-field') {
                // 绘制磁场边界
                ctx.strokeStyle = element.direction === 'out' ? '#e67700' : '#2b8a3e';
                ctx.lineWidth = 0.5; // 细线
                ctx.setLineDash([2, 2]);
                
                if (element.shape === 'rectangle') {
                    ctx.strokeRect(-element.width/2, -element.height/2, element.width, element.height);
                } else if (element.shape === 'circle') {
                    ctx.beginPath();
                    ctx.arc(0, 0, element.width/2, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (element.shape === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(0, -element.height/2);
                    ctx.lineTo(-element.width/2, element.height/2);
                    ctx.lineTo(element.width/2, element.height/2);
                    ctx.closePath();
                    ctx.stroke();
                } else if (element.shape === 'single-boundary') {
                    ctx.beginPath();
                    
                    const orientation = element.boundaryOrientation || 'vertical';
                    
                    // 计算画布可见区域
                    const visibleWidth = canvas.width / state.canvasScale;
                    const visibleHeight = canvas.height / state.canvasScale;
                    
                    if (orientation === 'vertical') {
                        // 竖直边界：x=0处的直线
                        ctx.moveTo(0, -visibleHeight/2);
                        ctx.lineTo(0, visibleHeight/2);
                    } else {
                        // 水平边界：y=0处的直线
                        ctx.moveTo(-visibleWidth/2, 0);
                        ctx.lineTo(visibleWidth/2, 0);
                    }
                    
                    ctx.stroke();
                } else if (element.shape === 'double-boundary') {
                    ctx.beginPath();
                    
                    // 获取可见画布大小
                    const visibleWidth = canvas.width / state.canvasScale;
                    
                    // 双边界：两条水平线，长度为整个画布宽度
                    const topY = -element.height/2;
                    const bottomY = element.height/2;
                    
                    // 绘制上边界线
                    ctx.moveTo(-visibleWidth/2, topY);
                    ctx.lineTo(visibleWidth/2, topY);
                    
                    // 绘制下边界线
                    ctx.moveTo(-visibleWidth/2, bottomY);
                    ctx.lineTo(visibleWidth/2, bottomY);
                    
                    ctx.stroke();
                }
                
                ctx.setLineDash([]);
                
                // 绘制磁场方向标记
                drawMagneticFieldMarkers(element);
            } else if (element.type === 'electric-field') {
                // 绘制电场边界
                ctx.strokeStyle = '#FFF9D4'; // 浅黄色表示电场
                ctx.lineWidth = 0.5; // 细线
                ctx.setLineDash([2, 2]);
                
                // 只保留矩形电场
                if (element.shape === 'rectangle') {
                    ctx.strokeRect(-element.width/2, -element.height/2, element.width, element.height);
                }
                
                ctx.setLineDash([]);
                
                // 绘制电场线（平行直线，带箭头）
                drawElectricFieldLines(element);
            }
            
            // 如果元素被选中，绘制选中框（在本地坐标系中绘制，自动跟随旋转）
            if (state.selectedElements.includes(element)) {
                ctx.strokeStyle = '#1971c2';
                ctx.lineWidth = 0.5; // 细线
                ctx.setLineDash([5, 5]);
                
                if (element.type === 'particle-emitter') {
                    // 计算矩形选择框大小，包含整个发射器和箭头
                    const arrowLength = element.radius * 5 +8; // 箭头长度 + 箭头头部长度
                    const boxHalfWidth = Math.max(element.radius + 10, arrowLength);
                    const boxHalfHeight = element.radius + 10;
                    
                    // 绘制矩形线框
                    ctx.strokeRect(-boxHalfWidth, -boxHalfHeight, boxHalfWidth , boxHalfHeight * 2);
                } else if (element.type === 'magnetic-field' || element.type === 'electric-field') {
                    if (element.shape === 'single-boundary') {
                        // 单边界场特殊选中框：包含边界和有场的区域
                        const orientation = element.boundaryOrientation || 'vertical';
                        const range = element.boundaryRange || 'right';
                        
                        // 获取可见画布大小
                        const visibleWidth = canvas.width / state.canvasScale;
                        const visibleHeight = canvas.height / state.canvasScale;
                        
                        if (orientation === 'vertical') {
                            // 竖直边界：选中框包含边界和场区域
                            const height = visibleHeight + 10;
                            const padding = 5;
                            
                            if (range === 'left') {
                                // 场在左侧，选中框从边界向左延伸到画布边缘
                                const width = visibleWidth/2 + padding;
                                const startX = -visibleWidth/2 - padding;
                                ctx.strokeRect(startX, -height/2, width, height);
                            } else {
                                // 场在右侧，选中框从边界向右延伸到画布边缘
                                const width = visibleWidth/2 + padding;
                                const startX = -padding;
                                ctx.strokeRect(startX, -height/2, width, height);
                            }
                        } else {
                            // 水平边界：选中框包含边界和场区域
                            const width = visibleWidth + 10;
                            const padding = 5;
                            
                            if (range === 'left') {
                                // 场在上侧，选中框从边界向上延伸到画布边缘
                                const height = visibleHeight/2 + padding;
                                const startY = -visibleHeight/2 - padding;
                                ctx.strokeRect(-width/2, startY, width, height);
                            } else {
                                // 场在下侧，选中框从边界向下延伸到画布边缘
                                const height = visibleHeight/2 + padding;
                                const startY = -padding;
                                ctx.strokeRect(-width/2, startY, width, height);
                            }
                        }
                    } else if (element.shape === 'circle') {
                        boundsWidth = element.width + 10;
                        boundsHeight = element.width + 10;
                        ctx.strokeRect(-boundsWidth/2, -boundsHeight/2, boundsWidth, boundsHeight);
                    } else if (element.shape === 'triangle') {
                        boundsWidth = element.width + 10;
                        boundsHeight = element.height + 10;
                        ctx.strokeRect(-boundsWidth/2, -boundsHeight/2, boundsWidth, boundsHeight);
                    } else if (element.shape === 'double-boundary') {
                        // 双边界场选中框：包含两条边界线和中间的场区域
                        const visibleWidth = canvas.width / state.canvasScale;
                        const padding = 5;
                        
                        // 选中框宽度为整个画布宽度，高度为两个边界之间的距离加上内边距
                        const width = visibleWidth + padding * 2;
                        const height = element.height + padding * 2;
                        
                        ctx.strokeRect(-width/2, -height/2, width, height);
                    } else {
                        boundsWidth = element.width + 10;
                        boundsHeight = element.height + 10;
                        ctx.strokeRect(-boundsWidth/2, -boundsHeight/2, boundsWidth, boundsHeight);
                    }
                }
                
                ctx.setLineDash([]);
            }
            
            ctx.restore();
        }

        // 绘制磁场方向标记
        function drawMagneticFieldMarkers(field) {
            const markerSpacing = 25; // 增大间距，减少标记数量
            
            // 计算标记数量
            let markers = [];
            
            if (field.shape === 'rectangle') {
                const cols = Math.floor(field.width / markerSpacing);
                const rows = Math.floor(field.height / markerSpacing);
                
                for (let i = 0; i <= cols; i++) {
                    for (let j = 0; j <= rows; j++) {
                        const x = -field.width/2 + i * markerSpacing;
                        const y = -field.height/2 + j * markerSpacing;
                        markers.push({x, y});
                    }
                }
            } else if (field.shape === 'circle') {
                const radius = field.width/2;
                const circles = Math.floor(radius / markerSpacing);
                
                for (let r = 1; r <= circles; r++) {
                    const currentRadius = r * markerSpacing;
                    const circumference = 2 * Math.PI * currentRadius;
                    const markersOnCircle = Math.floor(circumference / markerSpacing);
                    
                    for (let i = 0; i < markersOnCircle; i++) {
                        const angle = (i / markersOnCircle) * 2 * Math.PI;
                        const x = currentRadius * Math.cos(angle);
                        const y = currentRadius * Math.sin(angle);
                        
                        if (Math.sqrt(x*x + y*y) <= radius) {
                            markers.push({x, y});
                        }
                    }
                }
                
                // 添加中心点
                markers.push({x: 0, y: 0});
            } else if (field.shape === 'triangle') {
                // 三角形内的标记
                const rows = Math.ceil(field.height / markerSpacing);
                
                // 从顶部到底部绘制标记
                for (let row = 0; row <= rows; row++) {
                    const y = -field.height/2 + row * markerSpacing;
                    
                    // 检查y是否在三角形范围内
                    if (y <= field.height/2) {
                        // 计算当前高度处的三角形宽度（顶部0，底部field.width）
                    const progress = (y + field.height/2) / field.height; // 从0（顶部）到1（底部）
                    const widthAtY = field.width * progress;
                        const markersInRow = Math.max(0, Math.floor(widthAtY / markerSpacing));
                        
                        // 计算每行的起始x坐标，使标记居中
                        const startX = -widthAtY/2;
                        const step = widthAtY / Math.max(1, markersInRow);
                        
                        for (let i = 0; i <= markersInRow; i++) {
                            const x = startX + i * step;
                            markers.push({x, y});
                        }
                    }
                }
                
                // 添加中心点
                markers.push({x: 0, y: 0});
            } else if (field.shape === 'single-boundary') {
                // 单边界磁场标记：整个画布被一条线分割，一边有磁场，一边没有
                const orientation = field.boundaryOrientation || 'vertical';
                const range = field.boundaryRange || 'right';
                
                // 获取可见画布大小
                const visibleWidth = canvas.width / state.canvasScale;
                const visibleHeight = canvas.height / state.canvasScale;
                
                if (orientation === 'vertical') {
                    // 竖直边界：x=0处的直线，磁场在左侧或右侧
                    const rows = Math.ceil(visibleHeight / markerSpacing);
                    const cols = Math.ceil(visibleWidth / markerSpacing);
                    
                    for (let row = 0; row <= rows; row++) {
                        // 计算y坐标，覆盖整个可见画布高度
                        const y = -visibleHeight/2 + row * markerSpacing;
                        
                        if (range === 'left') {
                            // 磁场在左侧（x < 0）
                            for (let col = 0; col < cols; col++) {
                                const x = -visibleWidth/2 + col * markerSpacing;
                                if (x < 0) {
                                    markers.push({x, y});
                                }
                            }
                        } else {
                            // 磁场在右侧（x > 0）
                            for (let col = 0; col < cols; col++) {
                                const x = -visibleWidth/2 + col * markerSpacing;
                                if (x > 0) {
                                    markers.push({x, y});
                                }
                            }
                        }
                    }
                } else {
                    // 水平边界：y=0处的直线，磁场在上侧或下侧
                    const cols = Math.ceil(visibleWidth / markerSpacing);
                    const rows = Math.ceil(visibleHeight / markerSpacing);
                    
                    for (let col = 0; col <= cols; col++) {
                        // 计算x坐标，覆盖整个可见画布宽度
                        const x = -visibleWidth/2 + col * markerSpacing;
                        
                        if (range === 'left') {
                            // 磁场在上侧（y < 0）
                            for (let row = 0; row < rows; row++) {
                                const y = -visibleHeight/2 + row * markerSpacing;
                                if (y < 0) {
                                    markers.push({x, y});
                                }
                            }
                        } else {
                            // 磁场在下侧（y > 0）
                            for (let row = 0; row < rows; row++) {
                                const y = -visibleHeight/2 + row * markerSpacing;
                                if (y > 0) {
                                    markers.push({x, y});
                                }
                            }
                        }
                    }
                }
            } else if (field.shape === 'double-boundary') {
                // 双边界磁场标记：只在两条边界之间显示标记
                const visibleWidth = canvas.width / state.canvasScale;
                const topY = -field.height/2;
                const bottomY = field.height/2;
                
                // 计算标记行数和列数
                const rows = Math.ceil(field.height / markerSpacing);
                const cols = Math.ceil(visibleWidth / markerSpacing);
                
                for (let row = 0; row <= rows; row++) {
                    // 计算y坐标，在两条边界之间
                    const y = topY + (row + 0.5) * markerSpacing;
                    if (y < bottomY) {
                        // 只在两条边界之间显示标记
                        for (let col = 0; col < cols; col++) {
                            // 计算x坐标，覆盖整个可见画布宽度
                            const x = -visibleWidth/2 + col * markerSpacing;
                            markers.push({x, y});
                        }
                    }
                }
            }
            
            // 绘制标记
            ctx.fillStyle = field.direction === 'out' ? 'rgba(230, 119, 0, 0.8)' : 'rgba(43, 138, 62, 0.8)';
            ctx.font = '8px Arial'; // 更小的字体
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            markers.forEach(marker => {
                if (field.direction === 'out') {
                    // 垂直纸面向外，绘制"×"
                    ctx.fillText('×', marker.x, marker.y);
                } else {
                    // 垂直纸面向内，绘制"·"
                    ctx.fillText('•', marker.x, marker.y);
                }
            });
        }

        // 绘制电场线（平行直线，带箭头）
        function drawElectricFieldLines(field) {
            const lineSpacing = 30; // 电场线间距，原来的一半
            const arrowSize = 4; // 箭头大小
            
            // 计算电场方向（弧度）
            const fieldAngle = (field.direction * Math.PI) / 180;
            const cosAngle = Math.cos(fieldAngle);
            const sinAngle = Math.sin(fieldAngle);
            
            // 计算电场线数量
            let lines = [];
            
            if (field.shape === 'rectangle') {
                // 矩形电场：绘制平行线
                // 计算垂直于电场方向的最大宽度
                const perpendicularWidth = Math.abs(field.width * sinAngle) + Math.abs(field.height * cosAngle);
                const numLines = Math.floor(perpendicularWidth / lineSpacing);
                
                for (let i = 0; i <= numLines; i++) {
                    // 计算电场线的起始点和结束点
                    const offset = -perpendicularWidth/2 + i * lineSpacing;
                    
                    // 计算垂直于电场方向的偏移向量
                    const perpX = -sinAngle * offset;
                    const perpY = cosAngle * offset;
                    
                    // 沿着电场方向计算线的长度
                    const parallelLength = Math.abs(field.width * cosAngle) + Math.abs(field.height * sinAngle);
                    
                    // 计算线的起始点和结束点
                    const startX = perpX - cosAngle * parallelLength/2;
                    const startY = perpY - sinAngle * parallelLength/2;
                    const endX = perpX + cosAngle * parallelLength/2;
                    const endY = perpY + sinAngle * parallelLength/2;
                    
                    lines.push({startX, startY, endX, endY});
                }
            } 
           
    
            // 绘制电场线和箭头 - 改为深蓝色
            ctx.strokeStyle = 'rgba(255,249,212, 0.8)';
            ctx.fillStyle = 'rgba(255,249,212, 0.8)';
            ctx.lineWidth = 0.5;
            
            lines.forEach(line => {
                // 绘制电场线
                ctx.beginPath();
                ctx.moveTo(line.startX, line.startY);
                ctx.lineTo(line.endX, line.endY);
                ctx.stroke();
                
                // 绘制箭头：每条电场线只画一个箭头，位于线的中间位置
                // const arrowX = line.startX + (line.endX - line.startX) * 0.5;
                // const arrowY = line.startY + (line.endY - line.startY) * 0.5;
                const arrowX = line.endX
                const arrowY = line.endY
                // 绘制箭头
                ctx.save();
                ctx.translate(arrowX, arrowY);
                ctx.rotate(fieldAngle);
                
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-arrowSize, -arrowSize/2);
                ctx.lineTo(-arrowSize, arrowSize/2);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            });
        }

        // 绘制粒子
        function drawParticle(particle) {
            ctx.save();
            ctx.translate(particle.x, particle.y);
            
            ctx.fillStyle = particle.color;
            ctx.beginPath();
            ctx.arc(0, 0, particle.radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        // 绘制轨迹
        function drawTrajectory(trajectory) {
            if (trajectory.points.length < 2) return;
            
            ctx.save();
            ctx.strokeStyle = trajectory.color;
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 3]);
            
            ctx.beginPath();
            ctx.moveTo(trajectory.points[0].x, trajectory.points[0].y);
            
            for (let i = 1; i < trajectory.points.length; i++) {
                ctx.lineTo(trajectory.points[i].x, trajectory.points[i].y);
            }
            
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();
        }

        // 添加元素到画布
        function addElement(type) {
            let element;
            const centerX = (-state.canvasOffset.x + canvas.width/2) / state.canvasScale;
            const centerY = (-state.canvasOffset.y + canvas.height/2) / state.canvasScale;
            
            if (type === 'particle-emitter') {
                element = {
                    id: 'emitter_' + Date.now(),
                    type: 'particle-emitter',
                    x: centerX,
                    y: centerY,
                    radius: 6,
                    rotation: 0,
                    scale: 1.0,
                    particleType: 'electron',
                    speed: 30,
                    angle: 0,
                    emissionRate: 1,
                    lastEmissionTime: 0
                };
            } else if (type === 'magnetic-field') {
                element = {
                    id: 'field_' + Date.now(),
                    type: 'magnetic-field',
                    x: centerX,
                    y: centerY,
                    width: 200,
                    height: 150,
                    rotation: 0,
                    scale: 1.0,
                    shape: 'rectangle',
                    direction: 'out',
                    strength: 0.2,
                    // 单边界磁场属性
                    boundaryOrientation: 'vertical', // 竖直或水平
                    boundaryRange: 'right' // 左/上或右/下
                };
            } else if (type === 'electric-field') {
                element = {
                    id: 'electric_field_' + Date.now(),
                    type: 'electric-field',
                    x: centerX,
                    y: centerY,
                    width: 200,
                    height: 150,
                    rotation: 0,
                    scale: 1.0,
                    shape: 'rectangle',
                    direction: 0, // 电场方向角度，0°为水平向右
                    strength: 20,
                    // 单边界电场属性
                    boundaryOrientation: 'vertical', // 竖直或水平
                    boundaryRange: 'right' // 左/上或右/下
                };
            }
            
            state.elements.push(element);
            state.selectedElements = [element];
            state.selectedElement = element;
            
            // 显示变换控制按钮
            transformControls.classList.add('active');
            gestureHint.classList.add('active');
            
            updatePropertiesPanel();
            draw();
        }

        // 更新属性面板
        function updatePropertiesPanel() {
            if (state.selectedElements.length === 0) {
                noSelectionPanel.style.display = 'block';
                emitterProperties.style.display = 'none';
                fieldProperties.style.display = 'none';
                electricFieldProperties.style.display = 'none';
                transformPanel.style.display = 'none';
                physicsInfoPanel.style.display = 'block';
                return;
            }
            
            noSelectionPanel.style.display = 'none';
            physicsInfoPanel.style.display = 'block';
            transformPanel.style.display = 'block';
            
            // 当元素被选中时，自动显示右侧属性面板
            showSidebar('right');
            // 更新右侧面板活动时间
            updateSidebarActivity('right');
            
            // 如果有多个选中元素，只显示变换控制面板
            if (state.selectedElements.length > 1) {
                emitterProperties.style.display = 'none';
                fieldProperties.style.display = 'none';
                electricFieldProperties.style.display = 'none';
                updateTransformControls();
                return;
            }
            
            // 单个元素选中
            if (state.selectedElement.type === 'particle-emitter') {
                emitterProperties.style.display = 'block';
                fieldProperties.style.display = 'none';
                electricFieldProperties.style.display = 'none';
                
                // 更新控件值
                particleTypeSelect.value = state.selectedElement.particleType;
                particleSpeedInput.value = state.selectedElement.speed;
                particleAngleInput.value = state.selectedElement.angle;
                emissionRateInput.value = state.selectedElement.emissionRate;
                emitterSizeInput.value = state.selectedElement.radius;
                
                // 显示/隐藏自定义粒子属性
                if (state.selectedElement.particleType === 'custom') {
                    customParticleProperties.style.display = 'block';
                    customChargeInput.value = state.selectedElement.customCharge || -1;
                    customMassInput.value = state.selectedElement.customMass || 1;
                    customColorInput.value = state.selectedElement.customColor || '#4dabf7';
                } else {
                    customParticleProperties.style.display = 'none';
                }
                
                // 更新物理信息
                updatePhysicsInfo(state.selectedElement);
            } else if (state.selectedElement.type === 'magnetic-field') {
                emitterProperties.style.display = 'none';
                fieldProperties.style.display = 'block';
                electricFieldProperties.style.display = 'none';
                
                // 更新控件值
                fieldShapeSelect.value = state.selectedElement.shape;
                fieldDirectionSelect.value = state.selectedElement.direction;
                fieldStrengthInput.value = state.selectedElement.strength;
                fieldWidthInput.value = state.selectedElement.width;
                fieldHeightInput.value = state.selectedElement.height;
                fieldRotationInput.value = state.selectedElement.rotation;
                
                // 单边界和双边界磁场特殊处理
                if (state.selectedElement.shape === 'single-boundary') {
                    // 显示单边界特殊属性，隐藏宽度和高度
                    singleBoundaryProperties.style.display = 'block';
                    fieldWidthInput.parentElement.parentElement.style.display = 'none';
                    fieldHeightInput.parentElement.parentElement.style.display = 'none';
                    
                    // 更新单边界属性值
                    boundaryOrientationSelect.value = state.selectedElement.boundaryOrientation || 'vertical';
                    boundaryRangeSelect.value = state.selectedElement.boundaryRange || 'right';
                } else if (state.selectedElement.shape === 'double-boundary') {
                    // 双边界磁场：隐藏宽度和高度属性
                    singleBoundaryProperties.style.display = 'none';
                    fieldWidthInput.parentElement.parentElement.style.display = 'none';
                    fieldHeightInput.parentElement.parentElement.style.display = 'none';
                } else {
                    // 显示所有属性
                    singleBoundaryProperties.style.display = 'none';
                    fieldWidthInput.parentElement.parentElement.style.display = 'block';
                    fieldHeightInput.parentElement.parentElement.style.display = 'block';
                }
            } else if (state.selectedElement.type === 'electric-field') {
                emitterProperties.style.display = 'none';
                fieldProperties.style.display = 'none';
                electricFieldProperties.style.display = 'block';
                
                // 更新控件值
                electricFieldShapeSelect.value = state.selectedElement.shape;
                electricFieldDirectionInput.value = state.selectedElement.direction;
                electricFieldStrengthInput.value = state.selectedElement.strength;
                electricFieldWidthInput.value = state.selectedElement.width;
                electricFieldHeightInput.value = state.selectedElement.height;
                electricFieldRotationInput.value = state.selectedElement.rotation;
                
                // 单边界和双边界电场特殊处理
                // 只显示矩形电场的属性
                electricSingleBoundaryProperties.style.display = 'none';
                electricFieldWidthInput.parentElement.parentElement.style.display = 'block';
                electricFieldHeightInput.parentElement.parentElement.style.display = 'block';
            }
            
            // 更新变换控制面板
            updateTransformControls();
        }

        // 更新变换控制面板
        function updateTransformControls() {
            if (state.selectedElements.length === 0) return;
            
            // 如果有多个选中元素，显示第一个元素的位置
            const element = state.selectedElements[0];
            elementXInput.value = Math.round(element.x);
            elementYInput.value = Math.round(element.y);
            elementRotationInput.value = element.rotation;
            elementScaleInput.value = element.scale.toFixed(1);
        }

        // 更新物理信息显示
        function updatePhysicsInfo(emitter) {
            let particleData;
            
            if (emitter.particleType === 'custom') {
                particleData = {
                    name: '自定义粒子',
                    charge: emitter.customCharge || -1,
                    mass: emitter.customMass || 1,
                    color: emitter.customColor || '#4dabf7'
                };
            } else {
                particleData = PHYSICS_CONSTANTS[emitter.particleType.toUpperCase()];
            }
            
            if (!particleData) return;
            
            selectedParticleElement.textContent = particleData.name;
            particleChargeElement.textContent = `${particleData.charge} q`;
            particleMassElement.textContent = `${particleData.mass} m`;
            
            // 计算回旋半径和周期（高中物理简化公式）
            const magneticField = state.elements.find(el => el.type === 'magnetic-field');
            
            if (magneticField) {
                const charge = Math.abs(particleData.charge);
                const mass = particleData.mass;
                const speed = emitter.speed;
                const b = magneticField.strength;
                
                if (b > 0 && mass > 0 && speed > 0 && charge > 0) {
                    // 回旋半径 r = mv/(qB)
                    const gyroradius = (mass * speed) / (charge * b);
                    
                    // 回旋周期 T = 2πm/(qB)
                    const gyroperiod = (2 * Math.PI * mass) / (charge * b);
                    
                    gyroradiusElement.textContent = `${gyroradius.toFixed(2)} m`;
                    gyroperiodElement.textContent = `${gyroperiod.toFixed(2)} s`;
                } else {
                    gyroradiusElement.textContent = '0 m';
                    gyroperiodElement.textContent = '0 s';
                }
            } else {
                gyroradiusElement.textContent = '0 m';
                gyroperiodElement.textContent = '0 s';
            }
        }

        // 粒子发射函数
        function emitParticles(currentTime) {
            const emitters = state.elements.filter(el => el.type === 'particle-emitter');
            
            emitters.forEach(emitter => {
                const timeSinceLastEmission = currentTime - emitter.lastEmissionTime;
                // 发射频率基准为10s发射一个，输入10表示1s发射一个
                const emissionInterval = 10000 / emitter.emissionRate;
                
                if (timeSinceLastEmission >= emissionInterval) {
                    // 发射新粒子
                    let particleData;
                    
                    if (emitter.particleType === 'custom') {
                        particleData = {
                            name: '自定义粒子',
                            charge: emitter.customCharge || -1,
                            mass: emitter.customMass || 1,
                            color: emitter.customColor || '#4dabf7'
                        };
                    } else {
                        particleData = PHYSICS_CONSTANTS[emitter.particleType.toUpperCase()];
                    }
                    
                    if (!particleData) return;
                    
                    // 计算粒子初始位置（考虑发射器旋转和缩放）
                    // 粒子的发射方向应该是发射器旋转角度加上箭头角度
                    // 由于绘制时使用了负旋转角度，这里也需要使用负角度以保持一致
                    const totalAngle = -emitter.rotation + emitter.angle;
                    const angleRad = totalAngle * Math.PI / 180;
                    const offsetX = Math.cos(angleRad) * emitter.radius * emitter.scale;
                    const offsetY = -Math.sin(angleRad) * emitter.radius * emitter.scale;
                    
                    const particle = {
                        id: 'particle_' + Date.now() + Math.random(),
                        x: emitter.x + offsetX,
                        y: emitter.y + offsetY,
                        radius: 3,
                        color: particleData.color,
                        vx: Math.cos(angleRad) * emitter.speed,
                        vy: -Math.sin(angleRad) * emitter.speed,
                        speed: emitter.speed,
                        charge: particleData.charge,
                        mass: particleData.mass,
                        lifetime: 0,
                        maxLifetime: 30000, // 粒子存在时间(ms)
                        inMagneticField: false,
                        inElectricField: false,
                        electricAcceleration: { x: 0, y: 0 },
                        // 圆周运动相关参数
                        circleCenter: null,
                        circleRadius: 0,
                        angularSpeed: 0,
                        circleAngle: 0,
                        lastUpdateTime: currentTime,
                        // 电场运动相关参数
                        velocityPerpendicular: null, // 垂直电场方向速度
                        velocityParallel: null, // 平行电场方向速度
                        electricEntryTime: 0,
                        electricEntryPoint: null,
                        electricExitPoint: null
                    };
                    
                    state.particles.push(particle);
                    emitter.lastEmissionTime = currentTime;
                    
                    // 创建新轨迹
                    if (state.showTrajectories) {
                        state.trajectories.push({
                            particleId: particle.id,
                            points: [{x: particle.x, y: particle.y}],
                            color: particleData.color + '99' // 添加透明度
                        });
                    }
                }
            });
        }

        // 检查点是否在电场中
        function isPointInElectricField(x, y, field) {
            // 将点转换到电场局部坐标系
            const dx = x - field.x;
            const dy = y - field.y;
            
            // 考虑旋转
            const angle = -field.rotation * Math.PI / 180;
            const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);
            
            // 考虑缩放
            const scaledX = rotatedX / field.scale;
            const scaledY = rotatedY / field.scale;
            
            if (field.shape === 'rectangle') {
                return Math.abs(scaledX) <= field.width/2 && Math.abs(scaledY) <= field.height/2;
            } else if (field.shape === 'circle') {
                const distance = Math.sqrt(scaledX**2 + scaledY**2);
                return distance <= field.width/2;
            } else if (field.shape === 'triangle') {
                // 三角形检测（顶点在上，底边在下）
                const halfHeight = field.height/2;
                const halfWidth = field.width/2;
                
                // 三角形的三个顶点（局部坐标系）
                const vertex1 = { x: 0, y: -halfHeight }; // 顶部顶点
                const vertex2 = { x: -halfWidth, y: halfHeight }; // 左下顶点
                const vertex3 = { x: halfWidth, y: halfHeight }; // 右下顶点
                
                // 使用Barycentric坐标法判断点是否在三角形内
                // 计算三个边的向量
                const v0 = { x: vertex3.x - vertex1.x, y: vertex3.y - vertex1.y };
                const v1 = { x: vertex2.x - vertex1.x, y: vertex2.y - vertex1.y };
                const v2 = { x: scaledX - vertex1.x, y: scaledY - vertex1.y };
                
                // 计算点积
                const dot00 = v0.x * v0.x + v0.y * v0.y;
                const dot01 = v0.x * v1.x + v0.y * v1.y;
                const dot02 = v0.x * v2.x + v0.y * v2.y;
                const dot11 = v1.x * v1.x + v1.y * v1.y;
                const dot12 = v1.x * v2.x + v1.y * v2.y;
                
                // 计算Barycentric坐标
                const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
                const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                
                // 检查点是否在三角形内
                return (u >= 0) && (v >= 0) && (u + v <= 1);
            } else if (field.shape === 'single-boundary') {
                const orientation = field.boundaryOrientation || 'vertical';
                const range = field.boundaryRange || 'right';
                
                // 单边界电场：整个画布被一条线分割，一边有电场，另一边没有
                if (orientation === 'vertical') {
                    // 竖直边界：x=0处的直线
                    if (range === 'left') {
                        // 电场在左侧（x < 0）
                        return scaledX < 0;
                    } else {
                        // 电场在右侧（x > 0）
                        return scaledX > 0;
                    }
                } else {
                    // 水平边界：y=0处的直线
                    if (range === 'left') {
                        // 电场在上侧（y < 0）
                        return scaledY < 0;
                    } else {
                        // 电场在下侧（y > 0）
                        return scaledY > 0;
                    }
                }
            } else if (field.shape === 'double-boundary') {
                // 双边界：检查y坐标在两个边界之间
                const topY = -field.height/2;
                const bottomY = field.height/2;
                return scaledY >= topY && scaledY <= bottomY;
            }
            
            return false;
        }

        // 更新粒子运动（修正版，符合高中物理要求）
        function updateParticles(deltaTime) {
            // 检查场是否被移动或修改
            checkFieldsChanged();
            
            // 获取所有磁场和电场
            const magneticFields = state.elements.filter(el => el.type === 'magnetic-field');
            const electricFields = state.elements.filter(el => el.type === 'electric-field');
            
            // 更新每个粒子的位置
            state.particles.forEach((particle, index) => {
                // 增加粒子寿命
                particle.lifetime += deltaTime;
                
                // 如果粒子超过寿命，移除它
                if (particle.lifetime > particle.maxLifetime) {
                    state.particles.splice(index, 1);
                    // 同时移除对应的轨迹
                    if (state.showTrajectories) {
                        const trajectoryIndex = state.trajectories.findIndex(t => t.particleId === particle.id);
                        if (trajectoryIndex !== -1) {
                            state.trajectories.splice(trajectoryIndex, 1);
                        }
                    }
                    return;
                }
                
                // 检查粒子是否在磁场中
                let inMagneticField = false;
                let magneticField = null;
                
                for (const field of magneticFields) {
                    if (isPointInMagneticField(particle.x, particle.y, field)) {
                        inMagneticField = true;
                        magneticField = field;
                        break;
                    }
                }
                
                // 检查粒子是否在电场中
                let inElectricField = false;
                let electricField = null;
                
                for (const field of electricFields) {
                    if (isPointInElectricField(particle.x, particle.y, field)) {
                        inElectricField = true;
                        electricField = field;
                        break;
                    }
                }
                
                // 如果磁场状态发生变化
                if (inMagneticField !== particle.inMagneticField) {
                    particle.inMagneticField = inMagneticField;
                    
                    if (inMagneticField && magneticField) {
                        // 进入磁场，开始圆周运动
                        const bDirection = magneticField.direction === 'out' ? 1 : -1;
                        const bStrength = magneticField.strength;
                        
                        // 记录进入点
                        particle.entryPoint = { x: particle.x, y: particle.y };
                        particle.exitPoint = null;
                        
                        // 计算圆周运动参数
                        const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                        const charge = Math.abs(particle.charge);
                        
                        if (speed > 0 && charge > 0 && bStrength > 0) {
                            // 回旋半径 r = mv/(qB)
                            particle.circleRadius = (particle.mass * speed) / (charge * bStrength);
                            
                            // 角速度 ω = v/r = qB/m
                            particle.angularSpeed = (charge * bStrength) / particle.mass;
                            
                            // 确定旋转方向（考虑电荷正负和磁场方向）
                            const rotationDir = (particle.charge > 0 ? 1 : -1) * bDirection;
                            particle.angularSpeed *= rotationDir;
                            
                            // 计算圆心位置
                            // 圆心在速度垂直方向上，距离粒子为r
                            const speedDirX = particle.vx / speed;
                            const speedDirY = particle.vy / speed;
                            
                            // 垂直方向（顺时针旋转90度）
                            const perpendicularX = -speedDirY * rotationDir;
                            const perpendicularY = speedDirX * rotationDir;
                            
                            particle.circleCenter = {
                                x: particle.x + perpendicularX * particle.circleRadius,
                                y: particle.y + perpendicularY * particle.circleRadius
                            };
                            
                            // 计算初始角度
                            const dx = particle.x - particle.circleCenter.x;
                            const dy = particle.y - particle.circleCenter.y;
                            particle.circleAngle = Math.atan2(dy, dx);
                        }
                    } else {
                        // 离开磁场，保留轨迹圆但不再更新粒子圆周运动
                        particle.exitPoint = { x: particle.x, y: particle.y };
                        // 不清除circleCenter和circleRadius，保留轨迹圆
                        particle.angularSpeed = 0; // 停止圆周运动
                        particle.inMagneticField = false; // 标记为不在磁场中
                    }
                }
                
                // 如果电场状态发生变化
                if (inElectricField !== particle.inElectricField) {
                    particle.inElectricField = inElectricField;
                    
                    if (inElectricField && electricField) {
                        // 进入电场，计算加速度
                        // 电场方向角度（0°为水平向右，相对于电场区域）
                        const fieldDirectionAngle = electricField.direction * Math.PI / 180;
                        
                        // 考虑电场区域的旋转角度（相对于全局坐标系）
                        const fieldRotationAngle = electricField.rotation * Math.PI / 180;
                        
                        // 综合电场方向和区域旋转，得到最终的电场方向（全局坐标系）
                        const finalAngle = fieldDirectionAngle - fieldRotationAngle;
                        const cosAngle = Math.cos(finalAngle);
                        const sinAngle = Math.sin(finalAngle);
                        
                        // 电场强度
                        const eStrength = electricField.strength;
                        
                        // 粒子受到的力 F = qE
                        // 加速度 a = F/m = qE/m
                        const accelerationMagnitude = (Math.abs(particle.charge) * eStrength) / particle.mass;
                        
                        // 加速度方向：正电荷与电场方向相同，负电荷与电场方向相反
                        const directionMultiplier = particle.charge > 0 ? 1 : -1;
                        
                        // 计算加速度分量（全局坐标系）
                        particle.electricAcceleration.x = cosAngle * accelerationMagnitude * directionMultiplier;
                        particle.electricAcceleration.y = -sinAngle * accelerationMagnitude * directionMultiplier; // 注意负号，因为y轴向下为正
                        
                        // 记录进入点
                        particle.electricEntryPoint = { x: particle.x, y: particle.y };
                        particle.electricEntryTime = Date.now();
                        
                        // 将速度分解为平行和垂直于电场方向的分量
                        // 速度在电场方向上的投影（平行分量）
                        const speedParallel = particle.vx * cosAngle + particle.vy * (-sinAngle); // 注意vy需要取负号
                        
                        // 速度在垂直电场方向上的投影（垂直分量）
                        // 垂直方向单位向量：将电场方向旋转90度
                        const perpX = -sinAngle;
                        const perpY = -cosAngle; // 注意负号
                        const speedPerpendicular = particle.vx * perpX + particle.vy * perpY;
                        
                        // 保存分解后的速度
                        particle.velocityParallel = speedParallel;
                        particle.velocityPerpendicular = speedPerpendicular;
                        
                        // 保存电场方向单位向量
                        particle.electricFieldDirection = { x: cosAngle, y: -sinAngle };
                        particle.electricFieldPerpendicular = { x: perpX, y: perpY };
                    } else {
                        // 离开电场，清除加速度和分解速度
                        particle.electricAcceleration = { x: 0, y: 0 };
                        particle.electricExitPoint = { x: particle.x, y: particle.y };
                        particle.velocityPerpendicular = null;
                        particle.velocityParallel = null;
                        particle.electricFieldDirection = null;
                        particle.electricFieldPerpendicular = null;
                    }
                }
                
                // 更新粒子位置
                const dt = deltaTime / 1000; // 转换为秒
                
                if (particle.inMagneticField && particle.circleCenter) {
                    // 在磁场中做匀速圆周运动
                    particle.circleAngle += particle.angularSpeed * dt;
                    
                    particle.x = particle.circleCenter.x + particle.circleRadius * Math.cos(particle.circleAngle);
                    particle.y = particle.circleCenter.y + particle.circleRadius * Math.sin(particle.circleAngle);
                    
                    // 更新速度方向（切线方向）
                    const tangentX = -particle.circleRadius * Math.sin(particle.circleAngle) * particle.angularSpeed;
                    const tangentY = particle.circleRadius * Math.cos(particle.circleAngle) * particle.angularSpeed;
                    
                    particle.vx = tangentX;
                    particle.vy = tangentY;
                } else if (particle.inElectricField && particle.electricFieldDirection) {
                    // 在电场中做匀加速曲线运动
                    // 计算在电场中运动的时间（从进入电场开始）
                    const timeInField = (Date.now() - particle.electricEntryTime) / 1000;
                    
                    // 垂直电场方向：匀速直线运动
                    const perpDistance = particle.velocityPerpendicular * timeInField;
                    const perpX = particle.electricFieldPerpendicular.x * perpDistance;
                    const perpY = particle.electricFieldPerpendicular.y * perpDistance;
                    
                    // 平行电场方向：匀加速直线运动
                    // s = v0t + 1/2 a t^2
                    const parallelDistance = particle.velocityParallel * timeInField + 
                                           0.5 * (particle.electricAcceleration.x * particle.electricFieldDirection.x + 
                                                  particle.electricAcceleration.y * particle.electricFieldDirection.y) * timeInField * timeInField;
                    const parallelX = particle.electricFieldDirection.x * parallelDistance;
                    const parallelY = particle.electricFieldDirection.y * parallelDistance;
                    
                    // 计算新位置：起始点 + 垂直分量 + 平行分量
                    particle.x = particle.electricEntryPoint.x + perpX + parallelX;
                    particle.y = particle.electricEntryPoint.y + perpY + parallelY;
                    
                    // 更新速度：垂直分量不变，平行分量加上加速度×时间
                    const newParallelSpeed = particle.velocityParallel + 
                                           (particle.electricAcceleration.x * particle.electricFieldDirection.x + 
                                            particle.electricAcceleration.y * particle.electricFieldDirection.y) * timeInField;
                    
                    // 合成速度
                    particle.vx = particle.electricFieldPerpendicular.x * particle.velocityPerpendicular + 
                                particle.electricFieldDirection.x * newParallelSpeed;
                    particle.vy = particle.electricFieldPerpendicular.y * particle.velocityPerpendicular + 
                                particle.electricFieldDirection.y * newParallelSpeed;
                } else {
                    // 在场外做匀速直线运动
                    particle.x += particle.vx * dt;
                    particle.y += particle.vy * dt;
                }
                
                // 更新轨迹
                if (state.showTrajectories) {
                    const trajectory = state.trajectories.find(t => t.particleId === particle.id);
                    if (trajectory) {
                        trajectory.points.push({x: particle.x, y: particle.y});
                        
                        // 限制轨迹点数
                        if (trajectory.points.length > 1000) {
                            trajectory.points.shift();
                        }
                    }
                }
            });
            
            // 更新粒子计数显示
            particleCountElement.textContent = state.particles.length;
            state.simulationStep++;
        }

        // 检查点是否在磁场中
        function isPointInMagneticField(x, y, field) {
            // 将点转换到磁场局部坐标系
            const dx = x - field.x;
            const dy = y - field.y;
            
            // 考虑旋转
            const angle = -field.rotation * Math.PI / 180;
            const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);
            
            // 考虑缩放
            const scaledX = rotatedX / field.scale;
            const scaledY = rotatedY / field.scale;
            
            if (field.shape === 'rectangle') {
                return Math.abs(scaledX) <= field.width/2 && Math.abs(scaledY) <= field.height/2;
            } else if (field.shape === 'circle') {
                const distance = Math.sqrt(scaledX**2 + scaledY**2);
                return distance <= field.width/2;
            } else if (field.shape === 'triangle') {
                // 三角形检测（顶点在上，底边在下）
                const halfHeight = field.height/2;
                const halfWidth = field.width/2;
                
                // 三角形的三个顶点（局部坐标系）
                const vertex1 = { x: 0, y: -halfHeight }; // 顶部顶点
                const vertex2 = { x: -halfWidth, y: halfHeight }; // 左下顶点
                const vertex3 = { x: halfWidth, y: halfHeight }; // 右下顶点
                
                // 使用Barycentric坐标法判断点是否在三角形内
                // 计算三个边的向量
                const v0 = { x: vertex3.x - vertex1.x, y: vertex3.y - vertex1.y };
                const v1 = { x: vertex2.x - vertex1.x, y: vertex2.y - vertex1.y };
                const v2 = { x: scaledX - vertex1.x, y: scaledY - vertex1.y };
                
                // 计算点积
                const dot00 = v0.x * v0.x + v0.y * v0.y;
                const dot01 = v0.x * v1.x + v0.y * v1.y;
                const dot02 = v0.x * v2.x + v0.y * v2.y;
                const dot11 = v1.x * v1.x + v1.y * v1.y;
                const dot12 = v1.x * v2.x + v1.y * v2.y;
                
                // 计算Barycentric坐标
                const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
                const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                
                // 检查点是否在三角形内
                return (u >= 0) && (v >= 0) && (u + v <= 1);
            } else if (field.shape === 'single-boundary') {
                const orientation = field.boundaryOrientation || 'vertical';
                const range = field.boundaryRange || 'right';
                
                // 单边界磁场：整个画布被一条线分割，一边有磁场，另一边没有
                if (orientation === 'vertical') {
                    // 竖直边界：x=0处的直线
                    if (range === 'left') {
                        // 磁场在左侧（x < 0）
                        return scaledX < 0;
                    } else {
                        // 磁场在右侧（x > 0）
                        return scaledX > 0;
                    }
                } else {
                    // 水平边界：y=0处的直线
                    if (range === 'left') {
                        // 磁场在上侧（y < 0）
                        return scaledY < 0;
                    } else {
                        // 磁场在下侧（y > 0）
                        return scaledY > 0;
                    }
                }
            } else if (field.shape === 'double-boundary') {
                // 双边界：检查y坐标在两个边界之间
                const topY = -field.height/2;
                const bottomY = field.height/2;
                return scaledY >= topY && scaledY <= bottomY;
            }
            
            return false;
        }

        // 动画循环
        function animationLoop(currentTime) {
            if (!state.lastFrameTime) state.lastFrameTime = currentTime;
            
            const deltaTime = currentTime - state.lastFrameTime;
            
            if (state.simulationRunning) {
                // 发射新粒子
                emitParticles(currentTime);
                
                // 更新粒子位置
                updateParticles(deltaTime);
                
                // 重绘画布
                draw();
            }
            
            state.lastFrameTime = currentTime;
            requestAnimationFrame(animationLoop);
        }

        // 初始化事件监听器
        function initEventListeners() {
            // 悬浮按钮点击事件
            addEmitterBtn.addEventListener('click', () => {
                addElement('particle-emitter');
            });
            
            addFieldBtn.addEventListener('click', () => {
                addElement('magnetic-field');
            });
            
            addElectricFieldBtn.addEventListener('click', () => {
                addElement('electric-field');
            });
            
            // 粒子类型选择变化
            particleTypeSelect.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'particle-emitter') {
                    state.selectedElement.particleType = this.value;
                    
                    // 显示/隐藏自定义粒子属性
                    if (this.value === 'custom') {
                        customParticleProperties.style.display = 'block';
                        // 初始化自定义属性
                        if (!state.selectedElement.customCharge) {
                            state.selectedElement.customCharge = -1;
                            state.selectedElement.customMass = 1;
                            state.selectedElement.customColor = '#4dabf7';
                        }
                        customChargeInput.value = state.selectedElement.customCharge;
                        customMassInput.value = state.selectedElement.customMass;
                        customColorInput.value = state.selectedElement.customColor;
                    } else {
                        customParticleProperties.style.display = 'none';
                    }
                    
                    updatePhysicsInfo(state.selectedElement);
                    draw();
                }
            });
            
            // 自定义粒子属性变化
            customChargeInput.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'particle-emitter') {
                    state.selectedElement.customCharge = parseFloat(this.value);
                    updatePhysicsInfo(state.selectedElement);
                }
            });
            
            customMassInput.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'particle-emitter') {
                    state.selectedElement.customMass = parseFloat(this.value);
                    updatePhysicsInfo(state.selectedElement);
                }
            });
            
            customColorInput.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'particle-emitter') {
                    state.selectedElement.customColor = this.value;
                }
            });
            
            // 发射器属性变化事件
            particleSpeedInput.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'particle-emitter') {
                    state.selectedElement.speed = parseInt(this.value) || 30;
                    updatePhysicsInfo(state.selectedElement);
                }
            });
            
            particleAngleInput.addEventListener('input', function() {
                if (state.selectedElement && state.selectedElement.type === 'particle-emitter') {
                    state.selectedElement.angle = parseInt(this.value) || 0;
                    draw();
                }
            });
            
            particleAngleInput.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'particle-emitter') {
                    state.selectedElement.angle = parseInt(this.value) || 0;
                    draw();
                }
            });
            
            emissionRateInput.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'particle-emitter') {
                    state.selectedElement.emissionRate = parseFloat(this.value) || 10;
                }
            });
            
            emitterSizeInput.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'particle-emitter') {
                    state.selectedElement.radius = parseInt(this.value) || 20;
                    draw();
                }
            });
            
            // 磁场属性变化事件
            fieldShapeSelect.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'magnetic-field') {
                    state.selectedElement.shape = this.value;
                    draw();
                }
            });
            
            fieldDirectionSelect.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'magnetic-field') {
                    state.selectedElement.direction = this.value;
                    draw();
                }
            });
            
            fieldStrengthInput.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'magnetic-field') {
                    state.selectedElement.strength = parseFloat(this.value) || 1.0;
                    
                    // 如果有选中的发射器，更新物理信息
                    const emitter = state.elements.find(el => el.type === 'particle-emitter');
                    if (emitter) updatePhysicsInfo(emitter);
                }
            });
            
            fieldWidthInput.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'magnetic-field') {
                    state.selectedElement.width = parseInt(this.value) || 150;
                    draw();
                }
            });
            
            fieldHeightInput.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'magnetic-field') {
                    state.selectedElement.height = parseInt(this.value) || 100;
                    draw();
                }
            });
            
            fieldRotationInput.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'magnetic-field') {
                    state.selectedElement.rotation = parseInt(this.value) || 0;
                    draw();
                }
            });
            
            // 单边界磁场属性变化事件
            boundaryOrientationSelect.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'magnetic-field' && state.selectedElement.shape === 'single-boundary') {
                    state.selectedElement.boundaryOrientation = this.value;
                    draw();
                }
            });
            
            boundaryRangeSelect.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'magnetic-field' && state.selectedElement.shape === 'single-boundary') {
                    state.selectedElement.boundaryRange = this.value;
                    draw();
                }
            });
            
            // 电场属性变化事件
            electricFieldShapeSelect.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'electric-field') {
                    state.selectedElement.shape = this.value;
                    draw();
                }
            });
            
            electricFieldDirectionInput.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'electric-field') {
                    state.selectedElement.direction = parseInt(this.value) || 0;
                    draw();
                }
            });
            
            electricFieldStrengthInput.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'electric-field') {
                    state.selectedElement.strength = parseFloat(this.value) || 1.0;
                }
            });
            
            electricFieldWidthInput.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'electric-field') {
                    state.selectedElement.width = parseInt(this.value) || 150;
                    draw();
                }
            });
            
            electricFieldHeightInput.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'electric-field') {
                    state.selectedElement.height = parseInt(this.value) || 100;
                    draw();
                }
            });
            
            electricFieldRotationInput.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'electric-field') {
                    state.selectedElement.rotation = parseInt(this.value) || 0;
                    draw();
                }
            });
            
            // 单边界电场属性变化事件
            electricBoundaryOrientationSelect.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'electric-field' && state.selectedElement.shape === 'single-boundary') {
                    state.selectedElement.boundaryOrientation = this.value;
                    draw();
                }
            });
            
            electricBoundaryRangeSelect.addEventListener('change', function() {
                if (state.selectedElement && state.selectedElement.type === 'electric-field' && state.selectedElement.shape === 'single-boundary') {
                    state.selectedElement.boundaryRange = this.value;
                    draw();
                }
            });
            
            // 变换控制事件
            elementXInput.addEventListener('change', function() {
                if (state.selectedElements.length > 0) {
                    const deltaX = parseInt(this.value) - state.selectedElements[0].x;
                    state.selectedElements.forEach(element => {
                        element.x += deltaX;
                    });
                    draw();
                }
            });
            
            elementYInput.addEventListener('change', function() {
                if (state.selectedElements.length > 0) {
                    const deltaY = parseInt(this.value) - state.selectedElements[0].y;
                    state.selectedElements.forEach(element => {
                        element.y += deltaY;
                    });
                    draw();
                }
            });
            
            elementRotationInput.addEventListener('change', function() {
                if (state.selectedElements.length > 0) {
                    state.selectedElements.forEach(element => {
                        element.rotation = parseInt(this.value) || 0;
                    });
                    draw();
                }
            });
            
            elementScaleInput.addEventListener('change', function() {
                if (state.selectedElements.length > 0) {
                    const newScale = parseFloat(this.value) || 1.0;
                    const deltaScale = newScale / state.selectedElements[0].scale;
                    
                    state.selectedElements.forEach(element => {
                        element.scale *= deltaScale;
                    });
                    draw();
                }
            });
            
            // 变换按钮事件
            rotateLeftBtn.addEventListener('click', function() {
                if (state.selectedElements.length > 0) {
                    state.selectedElements.forEach(element => {
                        element.rotation = (element.rotation - 15) % 360;
                        if (element.rotation < 0) element.rotation += 360;
                    });
                    updateTransformControls();
                    draw();
                }
            });
            
            rotateRightBtn.addEventListener('click', function() {
                if (state.selectedElements.length > 0) {
                    state.selectedElements.forEach(element => {
                        element.rotation = (element.rotation + 15) % 360;
                    });
                    updateTransformControls();
                    draw();
                }
            });
            
            scaleUpBtn.addEventListener('click', function() {
                if (state.selectedElements.length > 0) {
                    state.selectedElements.forEach(element => {
                        element.scale = Math.min(3, element.scale * 1.1);
                    });
                    updateTransformControls();
                    draw();
                }
            });
            
            scaleDownBtn.addEventListener('click', function() {
                if (state.selectedElements.length > 0) {
                    state.selectedElements.forEach(element => {
                        element.scale = Math.max(0.1, element.scale * 0.9);
                    });
                    updateTransformControls();
                    draw();
                }
            });
            
            // 控制按钮事件
            startButton.addEventListener('click', function() {
                state.simulationRunning = !state.simulationRunning;
                
                if (state.simulationRunning) {
                    this.innerHTML = '<i class="fas fa-pause"></i> 暂停模拟';
                    this.classList.add('warning');
                } else {
                    this.innerHTML = '<i class="fas fa-play"></i> 开始模拟';
                    this.classList.remove('warning');
                }
                
                // 如果之前没有运行，确保有最后帧时间
                if (!state.lastFrameTime) {
                    state.lastFrameTime = performance.now();
                }
            });
            
            resetButton.addEventListener('click', function() {
                // 清除所有粒子和轨迹
                state.particles = [];
                state.trajectories = [];
                particleCountElement.textContent = '0';
                
                // 停止模拟
                state.simulationRunning = false;
                startButton.innerHTML = '<i class="fas fa-play"></i> 开始模拟';
                startButton.classList.remove('warning');
                
                draw();
            });
            
            trajectoryButton.addEventListener('click', function() {
                state.showTrajectories = !state.showTrajectories;
                
                if (state.showTrajectories) {
                    this.innerHTML = '<i class="fas fa-eye-slash"></i> 隐藏轨迹';
                    this.classList.add('primary');
                    
                    // 为现有粒子创建轨迹
                    state.particles.forEach(particle => {
                        const existingTrajectory = state.trajectories.find(t => t.particleId === particle.id);
                        if (!existingTrajectory) {
                            state.trajectories.push({
                                particleId: particle.id,
                                points: [{x: particle.x, y: particle.y}],
                                color: particle.color + '99'
                            });
                        }
                    });
                } else {
                    this.innerHTML = '<i class="fas fa-wave-square"></i> 显示轨迹';
                    this.classList.remove('primary');
                }
                
                draw();
            });
            
            clearButton.addEventListener('click', function() {
                // 清除所有元素、粒子和轨迹
                state.elements = [];
                state.particles = [];
                state.trajectories = [];
                state.selectedElements = [];
                state.selectedElement = null;
                
                // 停止模拟
                state.simulationRunning = false;
                startButton.innerHTML = '<i class="fas fa-play"></i> 开始模拟';
                startButton.classList.remove('warning');
                
                // 隐藏变换控制按钮
                transformControls.classList.remove('active');
                gestureHint.classList.remove('active');
                
                // 重置属性面板
                updatePropertiesPanel();
                
                particleCountElement.textContent = '0';
                draw();
            });
            
            // 删除元素按钮事件
            deleteElementButton.addEventListener('click', function() {
                if (state.selectedElements.length > 0) {
                    // 删除所有选中的元素
                    state.selectedElements.forEach(element => {
                        const index = state.elements.indexOf(element);
                        if (index !== -1) {
                            state.elements.splice(index, 1);
                        }
                    });
                    
                    state.selectedElements = [];
                    state.selectedElement = null;
                    
                    // 隐藏变换控制按钮
                    transformControls.classList.remove('active');
                    gestureHint.classList.remove('active');
                    
                    updatePropertiesPanel();
                    draw();
                }
            });
        }

        // 初始化应用
        function initApp() {
            initCanvas();
            initEventListeners();
            requestAnimationFrame(animationLoop);
        }

        // 页面加载完成后初始化应用
        window.addEventListener('load', initApp);
    </script>
</body>
</html>
