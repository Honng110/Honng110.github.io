<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8" />
    <title>双物块·配色统一·最终版</title>
    <!-- 解方程 -->
    <script src="js/all.min.js"></script>
    <!-- 显示公式（Latex） -->
    <script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Segoe+UI:wght@400;600&display=swap');

        :root {
            --bg: #f5f7fa;
            --card: #ffffff;
            --primary: #2196f3;
            --primary-dark: #1976d2;
            --text: #212121;
            --grid: #e8eaf0;
            --shadow: 0 8px 32px rgba(31, 38, 135, .15);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            background: var(--bg);
            height: 100vh;
            overflow: hidden;
            display: flex;
        }

        /* ---------- 左侧参数 ---------- */
        .panel {
            width: 280px;
            background: var(--card);
            border-radius: 16px;
            margin: 12px;
            box-shadow: var(--shadow);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: relative;
        }

        .panel h3 {
            margin: 0 0 10px;
            font-size: 18px;
            font-weight: 600;
            color: var(--text)
        }

        .row {
            display: flex;
            align-items: center;
            font-size: 14px
        }

        .row label {
            width: 150px;
            padding-right: 8px;
            color: var(--text)
        }

        .row input {
            width: 70px;
            padding: 6px 8px;
            border: 1.5px solid #ccd1d9;
            border-radius: 8px;
            transition: border .2s
        }

        .row input:focus {
            border-color: var(--primary);
            outline: none
        }

        .row span {
            margin-left: 6px;
            font-size: 12px;
            color: #6b7280
        }

        /* ---------- 切换按钮 ---------- */
        .switch-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: #fff;
            cursor: pointer;
            transition: all .2s;
            box-shadow: 0 2px 8px rgba(33, 150, 243, .3)
        }

        .switch-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(33, 150, 243, .4)
        }

        /* ---------- 共速信息区域 ---------- */
        .info-area {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px solid #e0e0e0;
            font-size: 14px;
            line-height: 1.6;
        }

        .info-area h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
        }

        .info-item {
            margin: 5px 0;
            color: #555;
        }

        .info-item.highlight {
            color: #d32f2f;
            font-weight: 600;
        }

        /* ---------- 右侧画布 ---------- */
        .right {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 12px
        }

        .top {
            display: flex;
            gap: 12px;
            height: 45%
        }

        .top canvas {
            flex: 1;
            background: var(--card);
            border-radius: 16px;
            box-shadow: var(--shadow)
        }

        .bottom {
            flex: 1;
            background: var(--card);
            border-radius: 16px;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px
        }

        .bottom canvas {
            border-radius: 12px
        }

        /* ---------- 按钮 ---------- */
        .ctrl {
            display: flex;
            gap: 12px
        }

        button {
            padding: 10px 24px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: #fff;
            cursor: pointer;
            transition: all .2s;
            box-shadow: 0 4px 12px rgba(33, 150, 243, .3)
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, .4)
        }

        button:active {
            transform: translateY(0)
        }

        ::-webkit-scrollbar {
            width: 6px
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c8d6;
            border-radius: 3px
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a7b0c2
        }
    </style>
</head>

<body>

    <!-- ================= 左侧参数面板 ================= -->
    <div class="panel">
        <button class="switch-btn" id="switchbtn" onclick="switchs()">切换</button>
        <h3 id="title">物块A 属性</h3>
        <div class="row"><label>初速度大小</label><input id="v0Mag" type="number" value="0" step="0.1"><span>m/s</span></div>
        <div class="row"><label>加速度</label><input id="accel" type="number" value="0" step="0.1"><span>m/s²</span></div>
        <div class="row"><label>初始位置</label><input type="text" id="coord" value="0"><span>m</span></div>
        <div class="row"><label>出发时间</label><input type="text" id="startime" value="0"><span>s</span></div>
        <!--关键：一个"弹簧"占位，把后续内容顶到下部 -->
        <div class="spacer"></div>
        <!-- 共速信息区域 -->
        <div class="info-area">
            <h4>运动概况(默认A追B)</h4>
            <div class="info-item" id="motioinfo">
                <label id="l1"></label>
                <label id="l2"></label>
                <label id="l3"></label>
                <label id="l4"></label>
                <label id="l5"></label>
                <label id="l6"></label>
            </div>
        </div>
    </div>

    <!-- ================= 右侧画布 ================= -->
    <div class="right">
        <div class="top">
            <canvas id="vtCvs"></canvas>
            <canvas id="xtCvs"></canvas>
        </div>
        <div class="bottom">
            <canvas id="mCvs"></canvas>
            <div class="ctrl">
                <button id="ctrlBtn" onclick="toggleCtrl()">开始</button>
                <button onclick="reset()">重置</button>
            </div>
        </div>
    </div>

    <script>
        /* ================= 画布尺寸 ================= */
        const vtCvs = document.getElementById('vtCvs'), xtCvs = document.getElementById('xtCvs'), mCvs = document.getElementById('mCvs');
        const vCtx = vtCvs.getContext('2d'), xCtx = xtCvs.getContext('2d'), mCtx = mCvs.getContext('2d');
        function resizeCvs() {
            const topH = document.querySelector('.top').clientHeight;
            const bottomH = document.querySelector('.bottom').clientHeight;
            const topW = document.querySelector('.top').clientWidth / 2 - 100;
            vtCvs.width = topW; vtCvs.height = topH - 12;
            xtCvs.width = topW; xtCvs.height = topH - 12;
            mCvs.width = document.querySelector('.bottom').clientWidth - 12;
            mCvs.height = bottomH - 70;
        }
        resizeCvs();
        window.addEventListener('resize', resizeCvs);

        /* ================= 工具：niceStep ================= */
        function niceStep(raw) {
            const pow10 = Math.pow(10, Math.floor(Math.log10(raw)));
            if (raw / pow10 > 5) return pow10 * 10;
            if (raw / pow10 > 2) return pow10 * 5;
            if (raw / pow10 > 1) return pow10 * 2;
            return pow10;
        }


        /* ================= 物块数据结构 ================= */
        const blocks = {
            A: {
                x0: 0, v0Mag: 0, accel: 0, startT: 0,
                color: '#2196f3', shadow: '#0d47a1', braceColor: '#2196f3'
            },
            B: {
                x0: 0, v0Mag: 0, accel: 0, startT: 0,
                color: '#4caf50', shadow: '#2e7d32', braceColor: '#4caf50'
            }
        };
        let currentBlock = 'A';   // 默认编辑 A
        let t = 0, dt = 0.01, aniId = null;

        let distance = 10;

        /* ================= 按钮控制 ================= */
        function toggleCtrl() { aniId ? pause() : start(); }
        function start() { if (!aniId) { aniId = requestAnimationFrame(frame); document.getElementById('ctrlBtn').textContent = '暂停'; } }
        function pause() { if (aniId) { cancelAnimationFrame(aniId); aniId = null; document.getElementById('ctrlBtn').textContent = '继续'; } }
        function reset() { pause(); t = 0; drawAll(); document.getElementById('ctrlBtn').textContent = '开始'; }
        function switchs() {
            // 保存当前面板数据
            saveFromPanel();
            // 切到另一个块
            currentBlock = (currentBlock === 'A') ? 'B' : 'A'; loadToPanel(currentBlock);
        }

        /* ================= 参数读写 ================= */
        function loadToPanel(block) {
            const b = blocks[block];
            document.getElementById('title').textContent = `物块${block} 属性`;
            document.getElementById('v0Mag').value = b.v0Mag;
            document.getElementById('accel').value = b.accel;
            document.getElementById('coord').value = b.x0;
            document.getElementById('startime').value = b.startT;
            currentBlock = block;
        }
        function saveFromPanel() {
            const b = blocks[currentBlock];
            // 解析初始坐标
            b.x0 = parseFloat(document.getElementById('coord').value) || 0;
            b.v0Mag = parseFloat(document.getElementById('v0Mag').value) || 0;
            b.accel = parseFloat(document.getElementById('accel').value) || 0;
            b.startT = parseFloat(document.getElementById('startime').value) || 0;
            drawAll();//更新界面
            motionall()
        }
        document.querySelectorAll('input').forEach(inp => inp.addEventListener('input', saveFromPanel));


        function motionall() {
            // const { Expression, Equation } = algebra;
            const distance = blocks.B.x0 - blocks.A.x0;
            const motion = (m) => {
                if (m.v0Mag === 0 && m.accel === 0) return "处于静止状态";
                if (m.v0Mag === 0 && m.accel > 0) return "向右做匀加速直线运动";
                if (m.v0Mag === 0 && m.accel < 0) return "向左做匀加速直线运动";
                if (m.v0Mag > 0 && m.accel === 0) return "向右做匀速直线运动";
                if (m.v0Mag < 0 && m.accel === 0) return "向左做匀速直线运动";
                if (m.v0Mag > 0 && m.accel > 0) return "向右做匀加速直线运动";
                if (m.v0Mag > 0 && m.accel < 0) return "向右做匀减速直线运动";
                if (m.v0Mag < 0 && m.accel > 0) return "向左做匀减速直线运动";
                if (m.v0Mag < 0 && m.accel < 0) return "向左做匀加速直线运动";
            };
            //解析时间的解
            const mt1 = (t) => {
                let tt = [];
                try {
                    if (t.length === 2) {
                        if (t[0] > 0) {
                            tt.push(t[0]);
                        }
                        if (t[1] > 0) {
                            tt.push(t[1]);
                        }
                    } else if (t.length === 0) {
                        return tt
                    } else {
                        tt.push(t.numer);
                    }
                    return tt
                } catch (e) {
                    return [];
                }
            }


            const meettime1 = (m, n) => {
                try {
                    var lstr = m.v0Mag + '*t+0.5*' + m.accel + '*(t-' + m.startT + ')^2+' + m.x0;
                    var rstr = n.v0Mag + '*t+0.5*' + n.accel + '*(t-' + n.startT + ')^2+' + n.x0;
                    var solutions = nerdamer(lstr + "=" + rstr).solveFor("t").toString();
                    var times = mt1(solutions);
                    if (times.length === 0) {
                        return "两物块不会相遇<br>";
                    } else if (times.length === 1) {
                        return "经过时间t=" + (Number.isInteger(times[0]) ? times[0].toString() : times[0].toFixed(2)) + "s ,二者相遇<br>";
                    } else if (times.length === 2) {
                        const [firstTime, secondTime] = times[0] < times[1] ? times : [times[1], times[0]];

                        return "经过时间t=" + (Number.isInteger(firstTime) ? firstTime.toString() : firstTime.toFixed(2)) + "s ,二者第一次相遇;<br>" + "经过时间t=" + (Number.isInteger(secondTime) ? secondTime.toString() : secondTime.toFixed(2)) + ",二者第二次相遇;<br>";

                    }
                } catch (e) {
                    return "二者不会相遇<br>";
                }
            }
            let html =
                `起始二者间距: ${distance} m <br>
                \`\sqrt{2}\`
                 物块A: ${motion(blocks.A)}<br>
                 物块B: ${motion(blocks.B)}<br>
                ${meettime1(blocks.A, blocks.B)}
                共同速度大小为<br>
                此时最大间距为<br>
                经过时间t=xx,二者第一次相遇<br>`
                ;
            html = html
                .replace(/左/g, '<span style="color:#2196f3">左</span>')
                .replace(/右/g, '<span style="color:#2196f3">右</span>')
                .replace(/加/g, '<span style="color:#f44336">加</span>')
                .replace(/减/g, '<span style="color:#f44336">减</span>');

            document.getElementById("motioinfo").innerHTML = html
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, "motioinfo"]);//手动触发
        }

        /* ================= 绘图 ================= */
        function drawAll() {
            const bA = blocks.A, bB = blocks.B;
            // const toRad = d => d * Math.PI / 180;
            /* 一维 */
            const v0xA = bA.v0Mag;
            const v0xB = bB.v0Mag;
            const x0A = bA.x0;
            const x0B = bB.x0;
            const axA = bA.accel;
            const axB = bB.accel;
            const t0A = bA.startT;
            const t0B = bB.startT;
            // const vA = v0xA + axA * t;
            // const vB = v0xB + axB * t;
            const sA = v0xA * t + 0.5 * axA * t * t;
            const sB = v0xB * t + 0.5 * axB * t * t;
            drawVT(v0xA, axA, v0xB, axB, t0A, t0B);
            drawXT(sA, sB, v0xA, axA, v0xB, axB, t0A, t0B, x0A, x0B);
            drawMotion(sA, sB);
        }

        function drawVT(v0xA, axA, v0xB, axB, t0A, t0B) {
            vCtx.clearRect(0, 0, vtCvs.width, vtCvs.height);

            /* ---------- 网格 ---------- */
            vCtx.strokeStyle = '#e0e0e0';
            vCtx.lineWidth = 1;
            for (let x = 0; x < vtCvs.width; x += 20) { vCtx.beginPath(); vCtx.moveTo(x, 0); vCtx.lineTo(x, vtCvs.height); vCtx.stroke(); }
            for (let y = 0; y < vtCvs.height; y += 20) { vCtx.beginPath(); vCtx.moveTo(0, y); vCtx.lineTo(vtCvs.width, y); vCtx.stroke(); }

            const margin = 30;
            /* 速度范围：± vMax （对称） */
            const vMax = Math.max(4, Math.abs(v0xA + axA * (t >= t0A ? (t - t0A) : 0)), Math.abs(v0xB + axB * (t >= t0B ? (t - t0B) : 0))) * 1.2;
            const tVis = Math.max(10, t * 1.2);            // 时间轴可见长度
            const scaleT = (vtCvs.width - 2 * margin) / tVis;
            const scaleV = (vtCvs.height - 2 * margin) / (2 * vMax); // 正负各一半

            /* 0 速度线（横轴）坐标 */
            const zeroY = vtCvs.height / 2;

            /* ---------- 坐标轴 ---------- */
            vCtx.strokeStyle = '#333'; vCtx.lineWidth = 2;
            // 横轴（0 速度）
            vCtx.beginPath(); vCtx.moveTo(margin, zeroY); vCtx.lineTo(vtCvs.width, zeroY); vCtx.stroke();
            // 纵轴（t=0）
            vCtx.beginPath(); vCtx.moveTo(margin, 0); vCtx.lineTo(margin, vtCvs.height); vCtx.stroke();

            /* 箭头 */
            vCtx.fillStyle = '#333';
            vCtx.beginPath(); vCtx.moveTo(vtCvs.width, zeroY); vCtx.lineTo(vtCvs.width - 8, zeroY - 4); vCtx.lineTo(vtCvs.width - 8, zeroY + 4); vCtx.closePath(); vCtx.fill();
            vCtx.beginPath(); vCtx.moveTo(margin, 0); vCtx.lineTo(margin - 4, 8); vCtx.lineTo(margin + 4, 8); vCtx.closePath(); vCtx.fill();

            /* 标签 */
            vCtx.font = '14px sans-serif'; vCtx.textAlign = 'center'; vCtx.fillText('t (s)', vtCvs.width - margin + 15, zeroY - 8);
            vCtx.save(); vCtx.translate(margin + 20, margin); vCtx.fillText('v (m/s)', 0, 0); vCtx.restore();

            /* ---------- 刻度 ---------- */
            const tInt = niceStep(tVis / 8);
            const vInt = niceStep(vMax / 5);
            vCtx.font = '12px sans-serif'; vCtx.fillStyle = '#333';
            // 时间刻度
            for (let i = 0; i <= Math.ceil(tVis / tInt) * tInt; i += tInt) {
                const x = margin + i * scaleT;
                vCtx.beginPath(); vCtx.moveTo(x, zeroY); vCtx.lineTo(x, zeroY + 6); vCtx.stroke();
                vCtx.textAlign = 'center'; vCtx.fillText(i.toFixed(0), x, zeroY + 18);
            }
            // 速度刻度（正负）
            for (let i = -Math.ceil(vMax / vInt) * vInt; i <= Math.ceil(vMax / vInt) * vInt; i += vInt) {
                if (Math.abs(i) < 1e-6) continue; // 跳过 0，已画横轴
                const y = zeroY - i * scaleV;
                vCtx.beginPath(); vCtx.moveTo(margin - 6, y); vCtx.lineTo(margin, y); vCtx.stroke();
                vCtx.textAlign = 'right'; vCtx.fillText(i.toFixed(0), margin - 8, y + 4);
            }

            /* ---------- 曲线 ---------- */
            const drawVOne = (v0, a, color, st) => {
                vCtx.strokeStyle = color; vCtx.lineWidth = 2; vCtx.beginPath();
                for (let tt = st; tt <= t; tt += dt) {
                    const vv = v0 + a * tt;
                    const x = margin + tt * scaleT;
                    const y = zeroY - vv * scaleV;
                    tt === st ? vCtx.moveTo(x, y) : vCtx.lineTo(x, y);
                }
                vCtx.stroke();
            };

            drawVOne(v0xA - axA * t0A, axA, '#2196f3', t0A);
            drawVOne(v0xB - axB * t0B, axB, '#4caf50', t0B);

            /* ---------- 当前点 ---------- */
            vCtx.fillStyle = '#ff9800';
            vCtx.beginPath(); vCtx.arc(margin + (t >= t0A ? t : t0A) * scaleT, zeroY - (v0xA + axA * (t >= t0A ? (t - t0A) : 0)) * scaleV, 5, 0, Math.PI * 2); vCtx.fill();
            xCtx.fillStyle = '#0f9800';
            vCtx.beginPath(); vCtx.arc(margin + (t >= t0B ? t : t0B) * scaleT, zeroY - (v0xB + axB * (t >= t0B ? (t - t0B) : 0)) * scaleV, 5, 0, Math.PI * 2); vCtx.fill();

        }

        function drawXT(sA, sB, v0xA, axA, v0xB, axB, t0A, t0B, x0A, x0B) {
            xCtx.clearRect(0, 0, xtCvs.width, xtCvs.height);

            /* ---------- 网格 ---------- */
            xCtx.strokeStyle = '#e0e0e0'; xCtx.lineWidth = 1;
            for (let x = 0; x < xtCvs.width; x += 20) { xCtx.beginPath(); xCtx.moveTo(x, 0); xCtx.lineTo(x, xtCvs.height); xCtx.stroke(); }
            for (let y = 0; y < xtCvs.height; y += 20) { xCtx.beginPath(); xCtx.moveTo(0, y); xCtx.lineTo(xtCvs.width, y); xCtx.stroke(); }

            const margin = 30;
            const tVis = Math.max(10, t * 1.2);

            /* 位移范围：± sMax */
            const xMin = Math.min(0, x0A, x0B, sA + x0A, sB + x0B);
            const xMax = Math.max(0, x0A, x0B, sA + x0A, sB + x0B);
            const sMax = Math.max(1, Math.abs(xMin), Math.abs(xMax)) * 1.2;

            const scaleT = (xtCvs.width - 2 * margin) / tVis;
            const scaleS = (xtCvs.height - 2 * margin) / (2 * sMax); // 正负对称
            const zeroY = xtCvs.height / 2;                          // 0 位移线

            /* ---------- 坐标轴 ---------- */
            xCtx.strokeStyle = '#333'; xCtx.lineWidth = 2;
            xCtx.beginPath(); xCtx.moveTo(margin, zeroY); xCtx.lineTo(xtCvs.width, zeroY); xCtx.stroke(); // 横轴
            xCtx.beginPath(); xCtx.moveTo(margin, 0); xCtx.lineTo(margin, xtCvs.height); xCtx.stroke();   // 纵轴

            /* 箭头 & 标签 */
            xCtx.fillStyle = '#333';
            xCtx.beginPath(); xCtx.moveTo(xtCvs.width, zeroY); xCtx.lineTo(xtCvs.width - 8, zeroY - 4); xCtx.lineTo(xtCvs.width - 8, zeroY + 4); xCtx.closePath(); xCtx.fill();
            xCtx.beginPath(); xCtx.moveTo(margin, 0); xCtx.lineTo(margin - 4, 8); xCtx.lineTo(margin + 4, 8); xCtx.closePath(); xCtx.fill();
            xCtx.font = '14px sans-serif'; xCtx.textAlign = 'center'; xCtx.fillText('t (s)', xtCvs.width - margin + 15, zeroY - 8);
            xCtx.save(); xCtx.translate(margin + 30, margin - 10); xCtx.fillText('x (m)', 0, 0); xCtx.restore();

            /* ---------- 刻度（与 v-t 完全一致） ---------- */
            const tInt = niceStep(tVis / 8);
            const xInt = niceStep(sMax / 5);          // 关键：步长可能 0.5、1、2 …
            xCtx.font = '12px sans-serif'; xCtx.fillStyle = '#333';

            // 时间刻度
            for (let i = 0; i <= Math.ceil(tVis / tInt) * tInt; i += tInt) {
                const x = margin + i * scaleT;
                xCtx.beginPath(); xCtx.moveTo(x, zeroY); xCtx.lineTo(x, zeroY + 6); xCtx.stroke();
                xCtx.textAlign = 'center'; xCtx.fillText(i.toFixed(0), x, zeroY + 18);
            }

            // 位移刻度（与 v-t 同一套逻辑）
            for (let i = -Math.ceil(sMax / xInt) * xInt; i <= Math.ceil(sMax / xInt) * xInt; i += xInt) {
                if (Math.abs(i) < 1e-6) continue;   // 宽松跳过 0，但不会误杀 ±1
                const y = zeroY - i * scaleS;
                xCtx.beginPath(); xCtx.moveTo(margin - 6, y); xCtx.lineTo(margin, y); xCtx.stroke();
                xCtx.textAlign = 'right'; xCtx.fillText(i.toFixed(1), margin - 8, y + 4);
            }

            /* ---------- 曲线 ---------- */
            const drawOne = (x0, v0, a, color, st) => {
                xCtx.strokeStyle = color; xCtx.lineWidth = 2; xCtx.beginPath();
                for (let tt = st; tt <= t; tt += dt) {
                    const xx = x0 + v0 * tt + 0.5 * a * tt * tt;
                    const x = margin + tt * scaleT;
                    const y = zeroY - xx * scaleS;
                    tt === 0 ? xCtx.moveTo(x, y) : xCtx.lineTo(x, y);
                }
                xCtx.stroke();
            };
            drawOne(x0A, v0xA, axA, '#2196f3', t0A);
            drawOne(x0B, v0xB, axB, '#4caf50', t0B);

            /* ---------- 当前点 ---------- */
            xCtx.fillStyle = '#ff9800';
            xCtx.beginPath(); xCtx.arc(margin + (t >= t0A ? t : t0A) * scaleT, zeroY - (sA + blocks.A.x0) * scaleS, 5, 0, Math.PI * 2); xCtx.fill();
            xCtx.fillStyle = '#0f9800';
            xCtx.beginPath(); xCtx.arc(margin + (t >= t0B ? t : t0B) * scaleT, zeroY - (sB + blocks.B.x0) * scaleS, 5, 0, Math.PI * 2); xCtx.fill();
        }



        function drawMotion(sA, sB) {
            mCtx.clearRect(0, 0, mCvs.width, mCvs.height);

            /* ---------- 网格 ---------- */
            mCtx.strokeStyle = '#e0e0e0'; mCtx.lineWidth = 1;
            for (let x = 0; x < mCvs.width; x += 20) { mCtx.beginPath(); mCtx.moveTo(x, 0); mCtx.lineTo(x, mCvs.height); mCtx.stroke(); }
            for (let y = 0; y < mCvs.height; y += 20) { mCtx.beginPath(); mCtx.moveTo(0, y); mCtx.lineTo(mCvs.width, y); mCtx.stroke(); }

            const margin = 40, groundY = mCvs.height - 50;

            /* 1. 位移范围：±xAbsMax，保底 1 m，步长≥1 */
            const xMin = Math.min(0, blocks.A.x0, blocks.B.x0, sA + blocks.A.x0, sB + blocks.B.x0);
            const xMax = Math.max(0, blocks.A.x0, blocks.B.x0, sA + blocks.A.x0, sB + blocks.B.x0);
            const xAbsMax = Math.max(1, Math.abs(xMin), Math.abs(xMax)) * 1.2;
            const scaleX = (mCvs.width - 2 * margin) / (2 * xAbsMax); // 对称比例
            const zeroX = mCvs.width / 2;                            // 原点居中

            /* 2. 地面 */
            mCtx.strokeStyle = '#5d4037'; mCtx.lineWidth = 2;
            mCtx.beginPath(); mCtx.moveTo(0, groundY); mCtx.lineTo(mCvs.width, groundY); mCtx.stroke();

            /* 3. 刻度：步长≥1，只跳过0标签 */
            const tickInt = Math.max(1, niceStep(xAbsMax / 5)); // 保证≥1
            mCtx.font = '13px sans-serif'; mCtx.fillStyle = '#333'; mCtx.textAlign = 'center';
            for (let i = -Math.ceil(xAbsMax / tickInt) * tickInt;
                i <= Math.ceil(xAbsMax / tickInt) * tickInt;
                i += tickInt) {
                const x = zeroX + i * scaleX;
                mCtx.beginPath(); mCtx.moveTo(x, groundY); mCtx.lineTo(x, groundY + 10); mCtx.stroke();
                if (i === 0) continue;          // 0只跳过文字
                mCtx.fillText(i.toFixed(0), x, groundY + 25);
            }

            /* 4. 物块（居中原点） */
            const blockSize = 4, blockLarge = 16;
            const isMoving = t > 0;
            const sizeA = isMoving ? blockSize : blockLarge;
            const sizeB = isMoving ? blockSize : blockLarge;

            const xA = zeroX + (blocks.A.x0 + sA) * scaleX;
            const xB = zeroX + (blocks.B.x0 + sB) * scaleX;
            const yA = groundY - sizeA;
            const yB = groundY;

            mCtx.fillStyle = '#2196f3'; mCtx.fillRect(xA - sizeA / 2, yA, sizeA, sizeA);
            mCtx.fillStyle = '#4caf50'; mCtx.fillRect(xB - sizeB / 2, yB, sizeB, sizeB);

            /* 5. 大括号（原点居中） */
            drawBrace(mCtx, zeroX + blocks.A.x0 * scaleX, xA, groundY - sizeA * 3 - 10, yA, '#2196f3', `sA = ${sA.toFixed(2)}m`);
            drawBrace(mCtx, zeroX + blocks.B.x0 * scaleX, xB, groundY - sizeB * 4 - 40, yB, '#4caf50', `sB = ${sB.toFixed(2)}m`);

            /* 6. 回传点击坐标 */
            window.blockPos = {
                A: { x: xA, y: yA + sizeA / 2 },
                B: { x: xB, y: yB + sizeB / 2 }
            };
        }

        /* 画大括号工具函数 */
        function drawBrace(ctx, x0, x1, yBrace, yBlock, color, text) {
            ctx.strokeStyle = color; ctx.lineWidth = 2;
            /* 虚线 */
            ctx.beginPath(); ctx.setLineDash([5]); ctx.moveTo(x0, yBrace); ctx.lineTo(x0, yBlock); ctx.stroke(); ctx.setLineDash([]);
            ctx.beginPath(); ctx.moveTo(x0, yBrace); ctx.lineTo(x0, yBrace - 8); ctx.lineTo((x0 + x1) / 2 - 8, yBrace - 8);
            ctx.moveTo((x0 + x1) / 2 + 8, yBrace - 8); ctx.lineTo(x1, yBrace - 8); ctx.lineTo(x1, yBrace); ctx.stroke();
            ctx.beginPath(); ctx.moveTo((x0 + x1) / 2 - 8, yBrace - 8); ctx.lineTo((x0 + x1) / 2 + 8, yBrace - 8); ctx.stroke();
            /* 虚线 */
            ctx.beginPath(); ctx.setLineDash([5]); ctx.moveTo(x1, yBrace); ctx.lineTo(x1, yBlock); ctx.stroke(); ctx.setLineDash([]);
            /* 文字 */
            ctx.fillStyle = color; ctx.font = '14px sans-serif'; ctx.textAlign = 'center';
            ctx.fillText(text, (x0 + x1) / 2, yBrace - 12);
        }

        /* ================= 动画帧 ================= */
        function frame() {
            t += dt;
            drawAll();
            aniId = requestAnimationFrame(frame);
        }
        /* ================= 初始化 ================= */
        reset();   // 先画一帧静止状态
    </script>
</body>

</html>
